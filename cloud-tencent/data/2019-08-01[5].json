{"code":0,"msg":"ok","data":{"total":68,"list":[{"id":2685,"type":40,"actionInfo":{"articleId":1409891,"columnId":75668,"articleOwnerUid":2952369},"createTime":1554275705,"detail":{"id":1409891,"articleId":1409891,"title":"git 入门教程之紧急修复\n                                                                            原","content":"entityMap|0|type|IMAGE|mutability|IMMUTABLE|data|imageUrl|https://ask.qcloudimg.com/http-save/yehe-2952369/riplt64csj.png|imageAlt|git-branch-snow.png|1|https://ask.qcloudimg.com/http-save/yehe-2952369/zdj25pwj2s.png|git-branch-issue-110.png|2|https://ask.qcloudimg.com/http-save/yehe-2952369/587e7975vd.png|git-branch-fixbug-master.png|3|https://ask.qcloudimg.com/http-save/yehe-2952369/bn41g6ubiz.png|git-branch-fixbug-snow.png|blocks|key|26u5a|text|unstyled|depth|inlineStyleRanges|entityRanges|2jvou|和往常一样,每个人团队开发者都在自己的本地分支上进行日常工作,相互独立又相互联系,一直以来相安无事,可是某天下午,上级领导突然急冲冲的打电话告诉你线上出bug了,需要你紧急修复,下班之前必须解决!|offset|length|style|CODE|8i0rb|我们天生就是创造+bug+的特殊群体,每天都在和各种各样的+bug+打交道,早已经习惯了这样的工作节奏,再也没有当初刚刚遇到紧急问题的手足无措,先喝杯茶,冷静一下,然后汇报领导说:放心吧!保证30min+内解决问题!|13c6t|背景|header-two|blrto|学习了分支操作的相关知识,团队内部就基本的开发流程达成一致:|fd06k|假设线上是主干+master+分支,开发是+dev+分支,团队成员是自定义+custom+分支,平时开发时在大家在各自+custom+分支上工作,完成分配任务后再合并到开发+dev+分支,等到开发分支功能稳定后,由项目领导负责合并到主干分支+master+.|bd4ib|+上述流程只是开发流程的简化版,实际情况更加复杂,后续再介绍+gitflow+工作流相关知识.\n+|blockquote|97ra9|由于是线上出现+bug,理所当然是基于+master+分支检出临时分支,修复分支代号为+issue-110,然后定位+bug+并提交,最后再合并到+master+分支,如此一来成功修复+bug,完成既定任务,心安理得准备下班回家!|17f1s|如果真的向上述步骤那样操作,显然还不够冷静,刚才那一杯茶算是白喝了!因为这样操作可能会丢失现场数据,那很多工作岂不是白做了,下面简单演示一下:|41nkh|错误示例|header-three|b3pkd|(一).+事发前正在自定义的+snow+分支上愉快编码中...|2mb95|#+线上分支+`master`,开发分支+`dev`,自定义分支+`snow`,当前正处于自定义分支\n$+git+branch\n++dev\n++master\n*+snow\n#+接到领导电话前正在自定义+`snow`+分支上进行愉快编码中...\n$+echo+\"Happy+coding\"+>>+test.txt\n$+git+add+test.txt\n$+git+commit+-m++\"Happy+coding\"|code-block|syntax|javascript|db402|?|atomic|nq6v|(二).+事发时直接检出主分+master+分支,并紧急修复+bug+.|18vle|(2.1)+基于+master+分支检出+issue-110+分支,并修复提交.|ad45r|#+注意:+事发时正在思考人生,此时更改尚未添加到暂存区!\n$+echo+\"who+am+i\"+>>+test.txt\n\n#+当前情况下,默认不允许直接切换到其他分支,因为工作区更改会被重写,这里为了演示错误示例,强制切换!\n$+git+checkout+-f+master+\n\n#+基于主干+`master`+分支检出修复+`issue-110`分支\n$+git+checkout+-b+issue-110\nSwitched+to+a+new+branch+'issue-110'\n\n#+定位线上+`bug`并修复,假设将+`fast+forward`+更改为+`fast+forward+not+recommend`,瞬间修复+`bug`有没有!\n$+cat+test.txt\nadd+test.txt\nsee+https://snowdreams1006.github.io/git/usage/remote-repository.html\nlearn+git+branch\nsee+https://snowdreams1006.github.io/git/usage/branch-overview.html\ngit+commit+c1\ngit+commit+c2+and+c3\ngit+checkout+-b+dev\nfast+forward\n$+vim+test.txt\n$+cat+test.txt\nadd+test.txt\nsee+https://snowdreams1006.github.io/git/usage/remote-repository.html\nlearn+git+branch\nsee+https://snowdreams1006.github.io/git/usage/branch-overview.html\ngit+commit+c1\ngit+commit+c2+and+c3\ngit+checkout+-b+dev\nfast+forward+not+recommend\n\n#+修复+`bug`+后,提交更改并备注已修复\n$+git+add+test.txt\n$+git+commit+-m+\"fix+bug+about+issue-110\"\n[issue-110+e60c8ad]+fix+bug+about+issue-110\n+1+file+changed,+1+insertion(%2B),+1+deletion(-)\nsunpodeMacBook-Pro:git-demo+sunpo$+git+status\nOn+branch+issue-110\nnothing+to+commit,+working+tree+clean\n$+|67nlm|42guk|(2.1)+切换到主干+master+分支,并合并修复+issue-110+分支|2dn0k|#+切换回+`master`+分支,合并修复+`issue-110`+分支\n$+git+checkout+master\nSwitched+to+branch+'master'\nYour+branch+is+up+to+date+with+'origin/master'.\n$+git+merge+issue-110\nUpdating+3fe94c0..e60c8ad\nFast-forward\n+test.txt+%7C+2+%2B-\n+1+file+changed,+1+insertion(%2B),+1+deletion(-)\n\n#+验证+`bug`+已修复:+更改为+`fast+forward+not+recommend`\n$+cat+test.txt\nadd+test.txt\nsee+https://snowdreams1006.github.io/git/usage/remote-repository.html\nlearn+git+branch\nsee+https://snowdreams1006.github.io/git/usage/branch-overview.html\ngit+commit+c1\ngit+commit+c2+and+c3\ngit+checkout+-b+dev\nfast+forward+not+recommend\n$+|cl3ao|5qeit|(三).+事发后切换回自定义+snow+分支,打算下班回家.|40gg|#+切换回+`snow`+分支,发现丢失了事发前的未保存更改:`who+am+i`\n$+git+checkout+snow\nSwitched+to+branch+'snow'\n$+cat+test.txt\nadd+test.txt\nsee+https://snowdreams1006.github.io/git/usage/remote-repository.html\nlearn+git+branch\nsee+https://snowdreams1006.github.io/git/usage/branch-overview.html\ngit+commit+c1\ngit+commit+c2+and+c3\ngit+checkout+-b+dev\nfast+forward\nHappy+coding\n$+|dtk0c|3kjvm|+现在还打算下班吗?你所做的更改因为没有提交或者不能提交造成全部丢失!\n+|6bq55|结果|header-four|4ffms|因为手头工作进行到一半无法提交或者忘记提交等原因,为了临时修复紧急+bug+而直接切换到目标分支再回来时发现更改全部丢失,相当于那部分工作白忙活了!|BOLD|ao9af|正确示例|89rrq|经过上述错误示例的惨痛教训后,再也不敢轻易切换分支了,原因在于工作区更改并没有被提交,或者说不能提交,如果能够有一种机制来保护案发现场,这样我们就能放心切换到其他分支工作,回来时一切如初,那该多好?|71kek|幸运的是,git+确实提供这么一种机制,git+stash+命令临时存储工作区,类似\"草稿箱\"作用.|ah18s|(一).+恢复工作区丢失更改,并使用+git+stash+命令保存现场.|c0jpo|#+修复工作区丢失更改:+同样未添加到暂存区\n$+echo+\"learn+git+stash\"+>>+test.txt\n$+cat+test.txt\nadd+test.txt\nsee+https://snowdreams1006.github.io/git/usage/remote-repository.html\nlearn+git+branch\nsee+https://snowdreams1006.github.io/git/usage/branch-overview.html\ngit+commit+c1\ngit+commit+c2+and+c3\ngit+checkout+-b+dev\nfast+forward\nHappy+coding\nlearn+git+stash\n\n#+保护现场:+存储到\"草稿箱\"\n$+git+stash\nSaved+working+directory+and+index+state+WIP+on+snow:+93227ba+Happy+coding|7gv2k|(二).+切换到开发+dev+分支并合并修复+issue-110+分支.|4hht7|#+切换到开发+`dev`+分支\n$+git+checkout+dev\nSwitched+to+branch+'dev'\nsunpodeMacBook-Pro:git-demo+sunpo$+git+status\nOn+branch+dev\nnothing+to+commit,+working+tree+clean\n#+合并修复+`issue-110`+分支\n$+git+merge+issue-110\nUpdating+3fe94c0..e60c8ad\nFast-forward\n+test.txt+%7C+2+%2B-\n+1+file+changed,+1+insertion(%2B),+1+deletion(-)\nsunpodeMacBook-Pro:git-demo+sunpo$+git+status\nOn+branch+dev\nnothing+to+commit,+working+tree+clean\n$+|e8ddf|(三).+切换回自定义+snow+分支,并恢复工作现场.|a0h9q|#+切换回自定义+`snow`+分支\n$+git+checkout+snow\nSwitched+to+branch+'snow'\nsunpodeMacBook-Pro:git-demo+sunpo$+git+status\nOn+branch+snow\nnothing+to+commit,+working+tree+clean\n$+|2i4uo|git+status+命令返回结果怎么显示工作区是干净的,好不容易才将丢失的更改找回来怎么又不见了?!逗我玩?|dfv4e|冷静,冷静,不要慌,既然工作现场已经保存到\"草稿箱\",那我们想要找回总要去\"草稿箱\"才能取出来吧?现在让我们看一下\"草稿箱\"有没有我们的工作现场?|ekqvm|#+查看存储的\"草稿箱\"列表\n$+git+stash+list\nstash@{0}:+WIP+on+snow:+93227ba+Happy+coding\n$+|2ld3m|+这里的+stash@{0}+是草稿+id,因为\"草稿箱\"允许保存多条草稿!\n+|751fp|现在放心了吧,保存的\"草稿\"安然无恙躺在未知的某个地方,现在我们想办法恢复回工作区即可!|1va46|git+stash+apply+恢复草稿,然后+git+stash+drop+删除草稿|unordered-list-item|84bdr|git+stash+pop+恢复并删除草稿|2muhv|#+恢复工作现场\n$+git+stash+pop\nOn+branch+snow\nChanges+not+staged+for+commit:\n++(use+\"git+add+<file>...\"+to+update+what+will+be+committed)\n++(use+\"git+checkout+--+<file>...\"+to+discard+changes+in+working+directory)\n\n++++modified:+++test.txt\n\nno+changes+added+to+commit+(use+\"git+add\"+and/or+\"git+commit+-a\")\nDropped+refs/stash@{0}+(b0c8ddc034d21f31204c82e9838fc5d4c01a49a8)\n\n#+工作现场已恢复,更改未添加到暂存区,`learn+git+stash`+又恢复了!\n$+git+status\nOn+branch+snow\nChanges+not+staged+for+commit:\n++(use+\"git+add+<file>...\"+to+update+what+will+be+committed)\n++(use+\"git+checkout+--+<file>...\"+to+discard+changes+in+working+directory)\n\n++++modified:+++test.txt\n\nno+changes+added+to+commit+(use+\"git+add\"+and/or+\"git+commit+-a\")\n$+cat+test.txt\nadd+test.txt\nsee+https://snowdreams1006.github.io/git/usage/remote-repository.html\nlearn+git+branch\nsee+https://snowdreams1006.github.io/git/usage/branch-overview.html\ngit+commit+c1\ngit+commit+c2+and+c3\ngit+checkout+-b+dev\nfast+forward\nHappy+coding\nlearn+git+stash|35i7d|96u0h|不论手头工作有没有提交,一旦工作区保存到\"草稿箱\"后,就放心大胆切换分支进行工作,回来时岁月静好,一切如初!|48dhb|小结|8vhm6|紧急修复+bug+时,可以通过+git+stash+保护工作现场,然后再切换到目标分支,检出修复分支,完成修复后切换到目标分支,合并修复分支,最后删除修复分支,此时再切换回本地分支后一切如初!|a6j38|工作区更改添加到\"草稿箱\"+:++git+stash,支持多次添加到\"草稿箱\"|cubm1|列出\"草稿箱\"内容+:+git+stash+list|b3kgr|恢复\"草稿箱\"内容+:+git+stash+apply|2a7eg|删除\"草稿箱\"内容+:+git+stash+drop|f2aei|恢复并删除\"草稿箱\"内容+:+git+stash+pop|66h64|恢复%7C删除指定\"草稿箱\"内容+:+git+stash+<stash-id>,例如+git+stash+apply+stash@{0}|4qsnv|+++++(adsbygoogle+=+window.adsbygoogle+%7C%7C+[]).push({});++^0|0|24|3|0|9|3|U|3|2O|5|0|0|0|8|6|M|3|12|6|1O|6|2F|3|3D|6|0|V|7|0|8|3|K|6|18|9|1N|3|22|6|2L|3|0|0|0|F|4|0|0|0|1|0|0|F|6|V|3|0|9|6|L|9|0|0|0|1|1|0|C|6|S|9|0|0|0|1|2|0|F|4|0|0|0|1|3|0|0|0|Y|3|13|4|0|0|0|5|3|K|9|0|J|9|0|0|B|3|N|9|0|0|C|4|0|0|0|A|0|0|0|5|9|0|0|0|F|O|E|0|0|D|0|0|0|0|0|5|3|G|9|0|H|9|0|C|E|0|C|F|0|C|E|0|F|D|0|H|K|15|P|0^^$0|$1|$2|3|4|5|6|$7|8|9|A]]|B|$2|3|4|5|6|$7|C|9|D]]|E|$2|3|4|5|6|$7|F|9|G]]|H|$2|3|4|5|6|$7|I|9|J]]]|K|@$L|M|N|-4|2|O|P|40|Q|@]|R|@]|6|$]]|$L|S|N|T|2|O|P|41|Q|@$U|42|V|43|W|X]]|R|@]|6|$]]|$L|Y|N|Z|2|O|P|44|Q|@$U|45|V|46|W|X]|$U|47|V|48|W|X]|$U|49|V|4A|W|X]]|R|@]|6|$]]|$L|10|N|11|2|12|P|4B|Q|@]|R|@]|6|$]]|$L|13|N|14|2|O|P|4C|Q|@]|R|@]|6|$]]|$L|15|N|16|2|O|P|4D|Q|@$U|4E|V|4F|W|X]|$U|4G|V|4H|W|X]|$U|4I|V|4J|W|X]|$U|4K|V|4L|W|X]|$U|4M|V|4N|W|X]|$U|4O|V|4P|W|X]]|R|@]|6|$]]|$L|17|N|18|2|19|P|4Q|Q|@$U|4R|V|4S|W|X]]|R|@]|6|$]]|$L|1A|N|1B|2|O|P|4T|Q|@$U|4U|V|4V|W|X]|$U|4W|V|4X|W|X]|$U|4Y|V|4Z|W|X]|$U|50|V|51|W|X]|$U|52|V|53|W|X]|$U|54|V|55|W|X]]|R|@]|6|$]]|$L|1C|N|1D|2|O|P|56|Q|@]|R|@]|6|$]]|$L|1E|N|1F|2|1G|P|57|Q|@]|R|@]|6|$]]|$L|1H|N|1I|2|O|P|58|Q|@$U|59|V|5A|W|X]]|R|@]|6|$]]|$L|1J|N|1K|2|1L|P|5B|Q|@]|R|@]|6|$1M|1N]]|$L|1O|N|1P|2|1Q|P|5C|Q|@]|R|@$U|5D|V|5E|L|5F]]|6|$]]|$L|1R|N|1S|2|O|P|5G|Q|@$U|5H|V|5I|W|X]|$U|5J|V|5K|W|X]]|R|@]|6|$]]|$L|1T|N|1U|2|O|P|5L|Q|@$U|5M|V|5N|W|X]|$U|5O|V|5P|W|X]]|R|@]|6|$]]|$L|1V|N|1W|2|1L|P|5Q|Q|@]|R|@]|6|$1M|1N]]|$L|1X|N|1P|2|1Q|P|5R|Q|@]|R|@$U|5S|V|5T|L|5U]]|6|$]]|$L|1Y|N|1Z|2|O|P|5V|Q|@$U|5W|V|5X|W|X]|$U|5Y|V|5Z|W|X]]|R|@]|6|$]]|$L|20|N|21|2|1L|P|60|Q|@]|R|@]|6|$1M|1N]]|$L|22|N|1P|2|1Q|P|61|Q|@]|R|@$U|62|V|63|L|64]]|6|$]]|$L|23|N|24|2|O|P|65|Q|@$U|66|V|67|W|X]]|R|@]|6|$]]|$L|25|N|26|2|1L|P|68|Q|@]|R|@]|6|$1M|1N]]|$L|27|N|1P|2|1Q|P|69|Q|@]|R|@$U|6A|V|6B|L|6C]]|6|$]]|$L|28|N|29|2|19|P|6D|Q|@]|R|@]|6|$]]|$L|2A|N|2B|2|2C|P|6E|Q|@]|R|@]|6|$]]|$L|2D|N|2E|2|O|P|6F|Q|@$U|6G|V|6H|W|X]|$U|6I|V|6J|W|2F]]|R|@]|6|$]]|$L|2G|N|2H|2|1G|P|6K|Q|@]|R|@]|6|$]]|$L|2I|N|2J|2|O|P|6L|Q|@]|R|@]|6|$]]|$L|2K|N|2L|2|O|P|6M|Q|@$U|6N|V|6O|W|X]|$U|6P|V|6Q|W|X]]|R|@]|6|$]]|$L|2M|N|2N|2|O|P|6R|Q|@$U|6S|V|6T|W|X]]|R|@]|6|$]]|$L|2O|N|2P|2|1L|P|6U|Q|@]|R|@]|6|$1M|1N]]|$L|2Q|N|2R|2|O|P|6V|Q|@$U|6W|V|6X|W|X]|$U|6Y|V|6Z|W|X]]|R|@]|6|$]]|$L|2S|N|2T|2|1L|P|70|Q|@]|R|@]|6|$1M|1N]]|$L|2U|N|2V|2|O|P|71|Q|@$U|72|V|73|W|X]]|R|@]|6|$]]|$L|2W|N|2X|2|1L|P|74|Q|@]|R|@]|6|$1M|1N]]|$L|2Y|N|2Z|2|O|P|75|Q|@$U|76|V|77|W|X]]|R|@]|6|$]]|$L|30|N|31|2|O|P|78|Q|@]|R|@]|6|$]]|$L|32|N|33|2|1L|P|79|Q|@]|R|@]|6|$1M|1N]]|$L|34|N|35|2|19|P|7A|Q|@$U|7B|V|7C|W|X]]|R|@]|6|$]]|$L|36|N|37|2|O|P|7D|Q|@]|R|@]|6|$]]|$L|38|N|39|2|3A|P|7E|Q|@$U|7F|V|7G|W|X]|$U|7H|V|7I|W|X]]|R|@]|6|$]]|$L|3B|N|3C|2|3A|P|7J|Q|@$U|7K|V|7L|W|X]]|R|@]|6|$]]|$L|3D|N|3E|2|1L|P|7M|Q|@]|R|@]|6|$1M|1N]]|$L|3F|N|2B|2|2C|P|7N|Q|@]|R|@]|6|$]]|$L|3G|N|3H|2|O|P|7O|Q|@]|R|@]|6|$]]|$L|3I|N|3J|2|12|P|7P|Q|@]|R|@]|6|$]]|$L|3K|N|3L|2|O|P|7Q|Q|@$U|7R|V|7S|W|X]|$U|7T|V|7U|W|X]]|R|@]|6|$]]|$L|3M|N|3N|2|3A|P|7V|Q|@$U|7W|V|7X|W|X]]|R|@]|6|$]]|$L|3O|N|3P|2|3A|P|7Y|Q|@$U|7Z|V|80|W|X]]|R|@]|6|$]]|$L|3Q|N|3R|2|3A|P|81|Q|@$U|82|V|83|W|X]]|R|@]|6|$]]|$L|3S|N|3T|2|3A|P|84|Q|@$U|85|V|86|W|X]]|R|@]|6|$]]|$L|3U|N|3V|2|3A|P|87|Q|@$U|88|V|89|W|X]]|R|@]|6|$]]|$L|3W|N|3X|2|3A|P|8A|Q|@$U|8B|V|8C|W|X]|$U|8D|V|8E|W|X]]|R|@]|6|$]]|$L|3Y|N|3Z|2|O|P|8F|Q|@]|R|@]|6|$]]]]","plain":"\n和往常一样,每个人团队开发者都在自己的本地分支上进行日常工作,相互独立又相互联系,一直以来相安无事,可是某天下午,上级领导突然急冲冲的打电话告诉你线上出bug了,需要你紧急修复,下班之前必须解决!\n我们天生就是创造 bug 的特殊群体,每天都在和各种各样的 bug 打交道,早已经习惯了这样的工作节奏,再也没有当初刚刚遇到紧急问题的手足无措,先喝杯茶,冷静一下,然后汇报领导说:放心吧!保证30min 内解决问题!\n背景\n学习了分支操作的相关知识,团队内部就基本的开发流程达成一致:\n假设线上是主干 master 分支,开发是 dev 分支,团队成员是自定义 custom 分支,平时开发时在大家在各自 custom 分支上工作,完成分配任务后再合并到开发 dev 分支,等到开发分支功能稳定后,由项目领导负责合并到主干分支 master .\n 上述流程只是开发流程的简化版,实际情况更加复杂,后续再介绍 gitflow 工作流相关知识.\n \n由于是线上出现 bug,理所当然是基于 master 分支检出临时分支,修复分支代号为 issue-110,然后定位 bug 并提交,最后再合并到 master 分支,如此一来成功修复 bug,完成既定任务,心安理得准备下班回家!\n如果真的向上述步骤那样操作,显然还不够冷静,刚才那一杯茶算是白喝了!因为这样操作可能会丢失现场数据,那很多工作岂不是白做了,下面简单演示一下:\n错误示例\n(一). 事发前正在自定义的 snow 分支上愉快编码中...\n# 线上分支 `master`,开发分支 `dev`,自定义分支 `snow`,当前正处于自定义分支\n$ git branch\n  dev\n  master\n* snow\n# 接到领导电话前正在自定义 `snow` 分支上进行愉快编码中...\n$ echo \"Happy coding\" >> test.txt\n$ git add test.txt\n$ git commit -m  \"Happy coding\"\n?\n(二). 事发时直接检出主分 master 分支,并紧急修复 bug .\n(2.1) 基于 master 分支检出 issue-110 分支,并修复提交.\n# 注意: 事发时正在思考人生,此时更改尚未添加到暂存区!\n$ echo \"who am i\" >> test.txt\n\n# 当前情况下,默认不允许直接切换到其他分支,因为工作区更改会被重写,这里为了演示错误示例,强制切换!\n$ git checkout -f master \n\n# 基于主干 `master` 分支检出修复 `issue-110`分支\n$ git checkout -b issue-110\nSwitched to a new branch 'issue-110'\n\n# 定位线上 `bug`并修复,假设将 `fast forward` 更改为 `fast forward not recommend`,瞬间修复 `bug`有没有!\n$ cat test.txt\nadd test.txt\nsee https://snowdreams1006.github.io/git/usage/remote-repository.html\nlearn git branch\nsee https://snowdreams1006.github.io/git/usage/branch-overview.html\ngit commit c1\ngit commit c2 and c3\ngit checkout -b dev\nfast forward\n$ vim test.txt\n$ cat test.txt\nadd test.txt\nsee https://snowdreams1006.github.io/git/usage/remote-repository.html\nlearn git branch\nsee https://snowdreams1006.github.io/git/usage/branch-overview.html\ngit commit c1\ngit commit c2 and c3\ngit checkout -b dev\nfast forward not recommend\n\n# 修复 `bug` 后,提交更改并备注已修复\n$ git add test.txt\n$ git commit -m \"fix bug about issue-110\"\n[issue-110 e60c8ad] fix bug about issue-110\n 1 file changed, 1 insertion(+), 1 deletion(-)\nsunpodeMacBook-Pro:git-demo sunpo$ git status\nOn branch issue-110\nnothing to commit, working tree clean\n$ \n?\n(2.1) 切换到主干 master 分支,并合并修复 issue-110 分支\n# 切换回 `master` 分支,合并修复 `issue-110` 分支\n$ git checkout master\nSwitched to branch 'master'\nYour branch is up to date with 'origin/master'.\n$ git merge issue-110\nUpdating 3fe94c0..e60c8ad\nFast-forward\n test.txt | 2 +-\n 1 file changed, 1 insertion(+), 1 deletion(-)\n\n# 验证 `bug` 已修复: 更改为 `fast forward not recommend`\n$ cat test.txt\nadd test.txt\nsee https://snowdreams1006.github.io/git/usage/remote-repository.html\nlearn git branch\nsee https://snowdreams1006.github.io/git/usage/branch-overview.html\ngit commit c1\ngit commit c2 and c3\ngit checkout -b dev\nfast forward not recommend\n$ \n?\n(三). 事发后切换回自定义 snow 分支,打算下班回家.\n# 切换回 `snow` 分支,发现丢失了事发前的未保存更改:`who am i`\n$ git checkout snow\nSwitched to branch 'snow'\n$ cat test.txt\nadd test.txt\nsee https://snowdreams1006.github.io/git/usage/remote-repository.html\nlearn git branch\nsee https://snowdreams1006.github.io/git/usage/branch-overview.html\ngit commit c1\ngit commit c2 and c3\ngit checkout -b dev\nfast forward\nHappy coding\n$ \n?\n 现在还打算下班吗?你所做的更改因为没有提交或者不能提交造成全部丢失!\n \n结果\n因为手头工作进行到一半无法提交或者忘记提交等原因,为了临时修复紧急 bug 而直接切换到目标分支再回来时发现更改全部丢失,相当于那部分工作白忙活了!\n正确示例\n经过上述错误示例的惨痛教训后,再也不敢轻易切换分支了,原因在于工作区更改并没有被提交,或者说不能提交,如果能够有一种机制来保护案发现场,这样我们就能放心切换到其他分支工作,回来时一切如初,那该多好?\n幸运的是,git 确实提供这么一种机制,git stash 命令临时存储工作区,类似\"草稿箱\"作用.\n(一). 恢复工作区丢失更改,并使用 git stash 命令保存现场.\n# 修复工作区丢失更改: 同样未添加到暂存区\n$ echo \"learn git stash\" >> test.txt\n$ cat test.txt\nadd test.txt\nsee https://snowdreams1006.github.io/git/usage/remote-repository.html\nlearn git branch\nsee https://snowdreams1006.github.io/git/usage/branch-overview.html\ngit commit c1\ngit commit c2 and c3\ngit checkout -b dev\nfast forward\nHappy coding\nlearn git stash\n\n# 保护现场: 存储到\"草稿箱\"\n$ git stash\nSaved working directory and index state WIP on snow: 93227ba Happy coding\n(二). 切换到开发 dev 分支并合并修复 issue-110 分支.\n# 切换到开发 `dev` 分支\n$ git checkout dev\nSwitched to branch 'dev'\nsunpodeMacBook-Pro:git-demo sunpo$ git status\nOn branch dev\nnothing to commit, working tree clean\n# 合并修复 `issue-110` 分支\n$ git merge issue-110\nUpdating 3fe94c0..e60c8ad\nFast-forward\n test.txt | 2 +-\n 1 file changed, 1 insertion(+), 1 deletion(-)\nsunpodeMacBook-Pro:git-demo sunpo$ git status\nOn branch dev\nnothing to commit, working tree clean\n$ \n(三). 切换回自定义 snow 分支,并恢复工作现场.\n# 切换回自定义 `snow` 分支\n$ git checkout snow\nSwitched to branch 'snow'\nsunpodeMacBook-Pro:git-demo sunpo$ git status\nOn branch snow\nnothing to commit, working tree clean\n$ \ngit status 命令返回结果怎么显示工作区是干净的,好不容易才将丢失的更改找回来怎么又不见了?!逗我玩?\n冷静,冷静,不要慌,既然工作现场已经保存到\"草稿箱\",那我们想要找回总要去\"草稿箱\"才能取出来吧?现在让我们看一下\"草稿箱\"有没有我们的工作现场?\n# 查看存储的\"草稿箱\"列表\n$ git stash list\nstash@{0}: WIP on snow: 93227ba Happy coding\n$ \n 这里的 stash@{0} 是草稿 id,因为\"草稿箱\"允许保存多条草稿!\n \n现在放心了吧,保存的\"草稿\"安然无恙躺在未知的某个地方,现在我们想办法恢复回工作区即可!\ngit stash apply 恢复草稿,然后 git stash drop 删除草稿\ngit stash pop 恢复并删除草稿\n# 恢复工作现场\n$ git stash pop\nOn branch snow\nChanges not staged for commit:\n  (use \"git add <file>...\" to update what will be committed)\n  (use \"git checkout -- <file>...\" to discard changes in working directory)\n\n    modified:   test.txt\n\nno changes added to commit (use \"git add\" and/or \"git commit -a\")\nDropped refs/stash@{0} (b0c8ddc034d21f31204c82e9838fc5d4c01a49a8)\n\n# 工作现场已恢复,更改未添加到暂存区,`learn git stash` 又恢复了!\n$ git status\nOn branch snow\nChanges not staged for commit:\n  (use \"git add <file>...\" to update what will be committed)\n  (use \"git checkout -- <file>...\" to discard changes in working directory)\n\n    modified:   test.txt\n\nno changes added to commit (use \"git add\" and/or \"git commit -a\")\n$ cat test.txt\nadd test.txt\nsee https://snowdreams1006.github.io/git/usage/remote-repository.html\nlearn git branch\nsee https://snowdreams1006.github.io/git/usage/branch-overview.html\ngit commit c1\ngit commit c2 and c3\ngit checkout -b dev\nfast forward\nHappy coding\nlearn git stash\n结果\n不论手头工作有没有提交,一旦工作区保存到\"草稿箱\"后,就放心大胆切换分支进行工作,回来时岁月静好,一切如初!\n小结\n紧急修复 bug 时,可以通过 git stash 保护工作现场,然后再切换到目标分支,检出修复分支,完成修复后切换到目标分支,合并修复分支,最后删除修复分支,此时再切换回本地分支后一切如初!\n工作区更改添加到\"草稿箱\" :  git stash,支持多次添加到\"草稿箱\"\n列出\"草稿箱\"内容 : git stash list\n恢复\"草稿箱\"内容 : git stash apply\n删除\"草稿箱\"内容 : git stash drop\n恢复并删除\"草稿箱\"内容 : git stash pop\n恢复|删除指定\"草稿箱\"内容 : git stash <stash-id>,例如 git stash apply stash@{0}\n     (adsbygoogle = window.adsbygoogle || []).push({});  ","brief":"\n和往常一样,每个人团队开发者都在自己的本地分支上进行日常工作,相互独立又相互联系,一直以来相安无事,可是某天下午,上级领导突然急冲冲的打电话告诉你线上出bug...","summary":"和往常一样,每个人团队开发者都在自己的本地分支上进行日常工作,相互独立又相互联系,一直以来相安无事,可是某天下午,上级领导突然急冲冲的打电话告诉你线上出bug了...","abstract":"和往常一样,每个人团队开发者都在自己的本地分支上进行日常工作,相互独立又相互联系,一直以来相安无事,可是某天下午,上级领导突然急冲冲的打电话告诉你线上出bug了...","description":"","picture":"https://ask.qcloudimg.com/http-save/yehe-2952369/riplt64csj.png","coverImageUrl":"https://ask.qcloudimg.com/http-save/yehe-2952369/riplt64csj.png","sourceType":99,"sourceDetail":{},"channelType":2,"channelDetail":{"source":"oschina","originalTime":"03/22 16:51"},"authorId":2952369,"columnId":75668,"writeTime":1554275705,"updateTime":1554275705,"viewCount":87,"likeCount":3,"commentCount":0,"weight":0,"status":2,"draftId":0,"tagIds":[],"tags":[{"tagId":10283,"tagName":"Git"}],"isCommentEnable":true,"column":{"id":75668,"name":"雪之梦技术驿站","desc":"雪之梦技术驿站又名snowdreams1006的技术小屋.主要分享个人的学习经验,一家之言,仅供参考.","icon":"https://ask.qcloudimg.com/column-icons/75668/2952369/rs2libapbs.png","background":"","status":2,"creatorId":2952369,"memberCount":1,"articleCount":67,"followCount":12,"createdTime":1553570025}}},{"id":2684,"type":40,"actionInfo":{"articleId":1409890,"columnId":75668,"articleOwnerUid":2952369},"createTime":1554275691,"detail":{"id":1409890,"articleId":1409890,"title":"git 入门教程之分支策略\n                                                                            原\n        ","content":"entityMap|0|type|IMAGE|mutability|IMMUTABLE|data|imageUrl|https://ask.qcloudimg.com/http-save/yehe-2952369/zz2zjxddax.png|imageAlt|git-merge-no-ff.png|1|https://ask.qcloudimg.com/http-save/yehe-2952369/3d9y213vbi.png|git-merge-no-ff-dev.png|2|https://ask.qcloudimg.com/http-save/yehe-2952369/w1ff5s21uc.png|git-merge-ff-dev.png|3|https://ask.qcloudimg.com/http-save/yehe-2952369/v4yg6cmzz4.png|git-merge-ff-dev-deleted.png|4|https://ask.qcloudimg.com/http-save/yehe-2952369/j4geq9fn7n.png|git-strategy.png|blocks|key|dgnpi|text|unstyled|depth|inlineStyleRanges|entityRanges|2tdde|默认情况下合并分支常常直接使用+git+merge+命令,是最方便快速的合并方法.其实这种情况下+git+采用的是+fast+forward+模式,特点是删除分支后,会丢失分支信息,好像从来没存在该分支一样,而我们推荐的是recursive+模式,能够保留分支的版本记录.|offset|length|style|CODE|2u24j|递归模式(recursive)|header-two|1rv6m|创建并切换+dev+分支,提交版本后切换回+master+分支,然后再合并+dev+分支,这不过这一次不再使用+git+merge+dev+命令:|dq4qd|#+创建并切换+dev+分支\n$+git+checkout+-b+dev\nSwitched+to+a+new+branch+'dev'\n#+提交版本\n$+echo+\"git+checkout+-b+dev\"+>>+test.txt\n$+git+add+test.txt\n$+git+commit+-m+\"git+checkout+-b+dev\"\n[dev+44d68f6]+git+checkout+-b+dev\n+1+file+changed,+1+insertion(%2B)\n#+切换回+master+分支\n$+git+checkout+master\nSwitched+to+branch+'master'\nYour+branch+is+ahead+of+'origin/master'+by+6+commits.\n++(use+\"git+push\"+to+publish+your+local+commits)\n$+|code-block|syntax|javascript|60ok1|现在添加+--no-ff+参数禁用+fast+forward+模式,即git+merge+--no-ff:|c6e56|$+git+merge+--no-ff+-m+\"git+merge+--no-ff+dev\"+dev\nMerge+made+by+the+'recursive'+strategy.\n+test.txt+%7C+1+%2B\n+1+file+changed,+1+insertion(%2B)\n$+|c29d4|上述内容显示,这次使用的不再是+fast+forward+模式,而是+recursive+模式,那让我们看一下提交历史有什么不同吧!|lbgg|$+git+log+--pretty=oneline+--graph\n*+++22fbef7+(HEAD+->+master)+git+merge+--no-ff+dev\n%7C\\++\n%7C+*+44d68f6(dev)+git+checkout+-b+dev\n%7C/++\n*+++3b8f434+fix+conflict\n%7C\\++\n%7C+*+0fe95f8+git+commit+c2\n*+%7C+0949cc3+git+commit+c3\n%7C/++\n*+5c482cd+git+commit+c1\n*+413a4d1+see+https://snowdreams1006.github.io/git/usage/branch-overview.html\n*+9c30e51+learn+git+branch\n*+b3d8193+(origin/master,+origin/HEAD)+see+https://snowdreams1006.github.io/git/usage/remote-repository.html\n*+8e62564+add+test.txt\n*+9b196aa+Initial+commit\n$+|kvlv|?|atomic|6n1q3|这种递归模式(recursive)+有一个明显的特点就是会产生一个新的+commit+,并不会像之前快速前进模式(fast+forward)那样单纯更改+HEAD+的指向.|ale1m|秉承着阅后即焚的习惯,分支一旦合并后就立即删除,现在删除+dev+分支,看一下会发生什么:|60cen|#+删除+dev+分支\n$+git+branch+-d+dev\nDeleted+branch+dev+(was+44d68f6).\n#+查看提交历史\n$+git+log+--pretty=oneline+--graph\n*+++22fbef7+(HEAD+->+master)+git+merge+--no-ff+dev\n%7C\\++\n%7C+*+44d68f6+git+checkout+-b+dev\n%7C/++\n*+++3b8f434+fix+conflict\n%7C\\++\n%7C+*+0fe95f8+git+commit+c2\n*+%7C+0949cc3+git+commit+c3\n%7C/++\n*+5c482cd+git+commit+c1\n*+413a4d1+see+https://snowdreams1006.github.io/git/usage/branch-overview.html\n*+9c30e50+learn+git+branch\n*+b3d8193+(origin/master,+origin/HEAD)+see+https://snowdreams1006.github.io/git/usage/remote-repository.html\n*+8e62564+add+test.txt\n*+9b196aa+Initial+commit\n$+|3u3uq|30m0n|由此可见,删除+dev+分支后仅仅少了+dev+的引用而已,原来+dev+分支所做的更改全部保留下来了!|b884q|快速前进模式(fast+forward)|803qq|创建并切换+dev+分支,提交版本后切换回+master+分支,然后再合并+dev+分支,使用+git+merge+dev+命令:|cn551|#+创建并切换+dev+分支\n$+git+checkout+-b+dev\nSwitched+to+a+new+branch+'dev'\n#+提交版本\n$+echo+\"fast+forward\"+>>+test.txt\n$+git+add+test.txt\n$+git+commit+-m+\"fast+forward\"\n[dev+3fe94c0]+fast+forward\n+1+file+changed,+1+insertion(%2B)\n$+|625j6|现在切换回+master+分支,采用默认的git+merge+命令合并+dev+分支:|bf5co|$+git+checkout+master\nSwitched+to+branch+'master'\nYour+branch+is+ahead+of+'origin/master'+by+8+commits.\n++(use+\"git+push\"+to+publish+your+local+commits)\nsunpodeMacBook-Pro:git-demo+sunpo$+git+merge+dev\nUpdating+22fbef7..3fe94c0\nFast-forward\n+test.txt+%7C+1+%2B\n+1+file+changed,+1+insertion(%2B)\n$+|9iplm|上述内容显示这次合并采用的是快速前进模式(fast+forward),让我们看一下提交历史:|31eg|$+git+log+--pretty=oneline+--graph\n*+3fe94c0+(HEAD+->+master,+dev)+fast+forward\n*+++22fbef7+git+merge+--no-ff+dev\n%7C\\++\n%7C+*+44d68f6+git+checkout+-b+dev\n%7C/++\n*+++3b8f434+fix+conflict\n%7C\\++\n%7C+*+0fe95f8+git+commit+c2\n*+%7C+0949cc3+git+commit+c3\n%7C/++\n*+5c482cd+git+commit+c1\n*+413a4d1+see+https://snowdreams1006.github.io/git/usage/branch-overview.html\n*+9c30e50+learn+git+branch\n*+b3d8193+(origin/master,+origin/HEAD)+see+https://snowdreams1006.github.io/git/usage/remote-repository.html\n*+8e62564+add+test.txt\n*+9b196aa+Initial+commit\n$+|2ua6b|上述内容表明,此次合并并没有产生新的+commit+,只是更改下+HEAD+指向而已(HEAD+->+master,+dev).|1v608|9ofvj|同样,现在删除+dev+分支,再看一下提交历史:|56bgp|#+删除+dev+分支\n$+git+branch+-d+dev\nDeleted+branch+dev+(was+3fe94c0).\n#+查看提交历史\n$+git+log+--pretty=oneline+--graph\n*+3fe94c0+(HEAD+->+master)+fast+forward\n*+++22fbef7+git+merge+--no-ff+dev\n%7C\\++\n%7C+*+44d68f6+git+checkout+-b+dev\n%7C/++\n*+++3b8f434+fix+conflict\n%7C\\++\n%7C+*+0fe95f8+git+commit+c2\n*+%7C+0949cc3+git+commit+c3\n%7C/++\n*+5c482cd+git+commit+c1\n*+413a4d1+see+https://snowdreams1006.github.io/git/usage/branch-overview.html\n*+9c30e50+learn+git+branch\n*+b3d8193+(origin/master,+origin/HEAD)+see+https://snowdreams1006.github.io/git/usage/remote-repository.html\n*+8e62564+add+test.txt\n*+9b196aa+Initial+commit\n$+|5h2a4|c48v8|由此可见,快速前进模式一旦删除分支后就彻底丢失了分支的信息,即便是从提交历史中也找不到曾经存在的痕迹!|ao283|分支策略|e2os3|git+是分布式版本控制系统,同时鼓励大量使用分支,如此一来大量的分支该如何管理?+实际开发中,建议准从以下原则进行分支管理:|damnt|master+分支作为主干分支,负责对外提供服务,要求稳定可靠,因为应该专人负责更新维护.|unordered-list-item|2rlu|dev+分支作为开发分支,取代+master+分支的开发地位,积累到一定产出时再合并到+master+分支.|5fs5f|feature+分支作为新功能分支,根据实际情况动态创建,删除分支,并适时合并到+dev+分支.|51b3u|bugFixed+分支作为修复特定+bug+分支,可能由+master+分支衍生而来,也可能由+dev+分支衍生等等,修复后及时合并到原分支.|b9o1j|custom+自定义分支,项目成员私有分支,由上级领导分配任务后各开发人员自行选择创建自己的分支,并根据实际情况决定合并到+dev+分支或+feature+等分支.|e62f1|7hl4s|小结|fejvc|快速前进模式(git+merge+<name>)不保留分支合并历史,递归模式(git+merge+--no-ff+-m+<remark>+<name>)保留分支合并历史.|dpemc|制定大家都认同的分支管理原则,并严格准守规则.|5sttm|+++++(adsbygoogle+=+window.adsbygoogle+%7C%7C+[]).push({});++^0|0|G|9|1D|3|1M|C|33|9|0|5|9|0|6|3|M|6|12|3|1K|D|0|0|5|7|I|C|Z|H|0|0|G|C|Z|9|0|0|0|1|0|0|7|9|10|6|1L|C|25|4|0|T|3|0|0|0|1|1|0|8|3|K|3|X|3|0|7|C|0|6|3|M|6|12|3|1C|D|0|0|6|6|L|9|10|3|0|0|L|C|0|0|J|6|X|4|17|J|0|0|1|2|0|8|3|0|0|0|1|3|0|0|0|0|3|0|0|6|0|0|3|G|6|18|6|0|0|7|15|3|0|0|8|T|6|1C|3|0|0|6|1Q|3|1Y|7|0|0|1|4|0|0|7|G|13|10|0|0^^$0|$1|$2|3|4|5|6|$7|8|9|A]]|B|$2|3|4|5|6|$7|C|9|D]]|E|$2|3|4|5|6|$7|F|9|G]]|H|$2|3|4|5|6|$7|I|9|J]]|K|$2|3|4|5|6|$7|L|9|M]]]|N|@$O|P|Q|-4|2|R|S|37|T|@]|U|@]|6|$]]|$O|V|Q|W|2|R|S|38|T|@$X|39|Y|3A|Z|10]|$X|3B|Y|3C|Z|10]|$X|3D|Y|3E|Z|10]|$X|3F|Y|3G|Z|10]]|U|@]|6|$]]|$O|11|Q|12|2|13|S|3H|T|@$X|3I|Y|3J|Z|10]]|U|@]|6|$]]|$O|14|Q|15|2|R|S|3K|T|@$X|3L|Y|3M|Z|10]|$X|3N|Y|3O|Z|10]|$X|3P|Y|3Q|Z|10]|$X|3R|Y|3S|Z|10]]|U|@]|6|$]]|$O|16|Q|17|2|18|S|3T|T|@]|U|@]|6|$19|1A]]|$O|1B|Q|1C|2|R|S|3U|T|@$X|3V|Y|3W|Z|10]|$X|3X|Y|3Y|Z|10]|$X|3Z|Y|40|Z|10]]|U|@]|6|$]]|$O|1D|Q|1E|2|18|S|41|T|@]|U|@]|6|$19|1A]]|$O|1F|Q|1G|2|R|S|42|T|@$X|43|Y|44|Z|10]|$X|45|Y|46|Z|10]]|U|@]|6|$]]|$O|1H|Q|1I|2|18|S|47|T|@]|U|@]|6|$19|1A]]|$O|1J|Q|1K|2|1L|S|48|T|@]|U|@$X|49|Y|4A|O|4B]]|6|$]]|$O|1M|Q|1N|2|R|S|4C|T|@$X|4D|Y|4E|Z|10]|$X|4F|Y|4G|Z|10]|$X|4H|Y|4I|Z|10]|$X|4J|Y|4K|Z|10]]|U|@]|6|$]]|$O|1O|Q|1P|2|R|S|4L|T|@$X|4M|Y|4N|Z|10]]|U|@]|6|$]]|$O|1Q|Q|1R|2|18|S|4O|T|@]|U|@]|6|$19|1A]]|$O|1S|Q|1K|2|1L|S|4P|T|@]|U|@$X|4Q|Y|4R|O|4S]]|6|$]]|$O|1T|Q|1U|2|R|S|4T|T|@$X|4U|Y|4V|Z|10]|$X|4W|Y|4X|Z|10]|$X|4Y|Y|4Z|Z|10]]|U|@]|6|$]]|$O|1V|Q|1W|2|13|S|50|T|@$X|51|Y|52|Z|10]]|U|@]|6|$]]|$O|1X|Q|1Y|2|R|S|53|T|@$X|54|Y|55|Z|10]|$X|56|Y|57|Z|10]|$X|58|Y|59|Z|10]|$X|5A|Y|5B|Z|10]]|U|@]|6|$]]|$O|1Z|Q|20|2|18|S|5C|T|@]|U|@]|6|$19|1A]]|$O|21|Q|22|2|R|S|5D|T|@$X|5E|Y|5F|Z|10]|$X|5G|Y|5H|Z|10]|$X|5I|Y|5J|Z|10]]|U|@]|6|$]]|$O|23|Q|24|2|18|S|5K|T|@]|U|@]|6|$19|1A]]|$O|25|Q|26|2|R|S|5L|T|@$X|5M|Y|5N|Z|10]]|U|@]|6|$]]|$O|27|Q|28|2|18|S|5O|T|@]|U|@]|6|$19|1A]]|$O|29|Q|2A|2|R|S|5P|T|@$X|5Q|Y|5R|Z|10]|$X|5S|Y|5T|Z|10]|$X|5U|Y|5V|Z|10]]|U|@]|6|$]]|$O|2B|Q|1K|2|1L|S|5W|T|@]|U|@$X|5X|Y|5Y|O|5Z]]|6|$]]|$O|2C|Q|2D|2|R|S|60|T|@$X|61|Y|62|Z|10]]|U|@]|6|$]]|$O|2E|Q|2F|2|18|S|63|T|@]|U|@]|6|$19|1A]]|$O|2G|Q|1K|2|1L|S|64|T|@]|U|@$X|65|Y|66|O|67]]|6|$]]|$O|2H|Q|2I|2|R|S|68|T|@]|U|@]|6|$]]|$O|2J|Q|2K|2|13|S|69|T|@]|U|@]|6|$]]|$O|2L|Q|2M|2|R|S|6A|T|@$X|6B|Y|6C|Z|10]]|U|@]|6|$]]|$O|2N|Q|2O|2|2P|S|6D|T|@$X|6E|Y|6F|Z|10]]|U|@]|6|$]]|$O|2Q|Q|2R|2|2P|S|6G|T|@$X|6H|Y|6I|Z|10]|$X|6J|Y|6K|Z|10]|$X|6L|Y|6M|Z|10]]|U|@]|6|$]]|$O|2S|Q|2T|2|2P|S|6N|T|@$X|6O|Y|6P|Z|10]|$X|6Q|Y|6R|Z|10]]|U|@]|6|$]]|$O|2U|Q|2V|2|2P|S|6S|T|@$X|6T|Y|6U|Z|10]|$X|6V|Y|6W|Z|10]|$X|6X|Y|6Y|Z|10]]|U|@]|6|$]]|$O|2W|Q|2X|2|2P|S|6Z|T|@$X|70|Y|71|Z|10]|$X|72|Y|73|Z|10]|$X|74|Y|75|Z|10]]|U|@]|6|$]]|$O|2Y|Q|1K|2|1L|S|76|T|@]|U|@$X|77|Y|78|O|79]]|6|$]]|$O|2Z|Q|30|2|13|S|7A|T|@]|U|@]|6|$]]|$O|31|Q|32|2|2P|S|7B|T|@$X|7C|Y|7D|Z|10]|$X|7E|Y|7F|Z|10]]|U|@]|6|$]]|$O|33|Q|34|2|2P|S|7G|T|@]|U|@]|6|$]]|$O|35|Q|36|2|R|S|7H|T|@]|U|@]|6|$]]]]","plain":"\n默认情况下合并分支常常直接使用 git merge 命令,是最方便快速的合并方法.其实这种情况下 git 采用的是 fast forward 模式,特点是删除分支后,会丢失分支信息,好像从来没存在该分支一样,而我们推荐的是recursive 模式,能够保留分支的版本记录.\n递归模式(recursive)\n创建并切换 dev 分支,提交版本后切换回 master 分支,然后再合并 dev 分支,这不过这一次不再使用 git merge dev 命令:\n# 创建并切换 dev 分支\n$ git checkout -b dev\nSwitched to a new branch 'dev'\n# 提交版本\n$ echo \"git checkout -b dev\" >> test.txt\n$ git add test.txt\n$ git commit -m \"git checkout -b dev\"\n[dev 44d68f6] git checkout -b dev\n 1 file changed, 1 insertion(+)\n# 切换回 master 分支\n$ git checkout master\nSwitched to branch 'master'\nYour branch is ahead of 'origin/master' by 6 commits.\n  (use \"git push\" to publish your local commits)\n$ \n现在添加 --no-ff 参数禁用 fast forward 模式,即git merge --no-ff:\n$ git merge --no-ff -m \"git merge --no-ff dev\" dev\nMerge made by the 'recursive' strategy.\n test.txt | 1 +\n 1 file changed, 1 insertion(+)\n$ \n上述内容显示,这次使用的不再是 fast forward 模式,而是 recursive 模式,那让我们看一下提交历史有什么不同吧!\n$ git log --pretty=oneline --graph\n*   22fbef7 (HEAD -> master) git merge --no-ff dev\n|\\  \n| * 44d68f6(dev) git checkout -b dev\n|/  \n*   3b8f434 fix conflict\n|\\  \n| * 0fe95f8 git commit c2\n* | 0949cc3 git commit c3\n|/  \n* 5c482cd git commit c1\n* 413a4d1 see https://snowdreams1006.github.io/git/usage/branch-overview.html\n* 9c30e51 learn git branch\n* b3d8193 (origin/master, origin/HEAD) see https://snowdreams1006.github.io/git/usage/remote-repository.html\n* 8e62564 add test.txt\n* 9b196aa Initial commit\n$ \n?\n这种递归模式(recursive) 有一个明显的特点就是会产生一个新的 commit ,并不会像之前快速前进模式(fast forward)那样单纯更改 HEAD 的指向.\n秉承着阅后即焚的习惯,分支一旦合并后就立即删除,现在删除 dev 分支,看一下会发生什么:\n# 删除 dev 分支\n$ git branch -d dev\nDeleted branch dev (was 44d68f6).\n# 查看提交历史\n$ git log --pretty=oneline --graph\n*   22fbef7 (HEAD -> master) git merge --no-ff dev\n|\\  \n| * 44d68f6 git checkout -b dev\n|/  \n*   3b8f434 fix conflict\n|\\  \n| * 0fe95f8 git commit c2\n* | 0949cc3 git commit c3\n|/  \n* 5c482cd git commit c1\n* 413a4d1 see https://snowdreams1006.github.io/git/usage/branch-overview.html\n* 9c30e50 learn git branch\n* b3d8193 (origin/master, origin/HEAD) see https://snowdreams1006.github.io/git/usage/remote-repository.html\n* 8e62564 add test.txt\n* 9b196aa Initial commit\n$ \n?\n由此可见,删除 dev 分支后仅仅少了 dev 的引用而已,原来 dev 分支所做的更改全部保留下来了!\n快速前进模式(fast forward)\n创建并切换 dev 分支,提交版本后切换回 master 分支,然后再合并 dev 分支,使用 git merge dev 命令:\n# 创建并切换 dev 分支\n$ git checkout -b dev\nSwitched to a new branch 'dev'\n# 提交版本\n$ echo \"fast forward\" >> test.txt\n$ git add test.txt\n$ git commit -m \"fast forward\"\n[dev 3fe94c0] fast forward\n 1 file changed, 1 insertion(+)\n$ \n现在切换回 master 分支,采用默认的git merge 命令合并 dev 分支:\n$ git checkout master\nSwitched to branch 'master'\nYour branch is ahead of 'origin/master' by 8 commits.\n  (use \"git push\" to publish your local commits)\nsunpodeMacBook-Pro:git-demo sunpo$ git merge dev\nUpdating 22fbef7..3fe94c0\nFast-forward\n test.txt | 1 +\n 1 file changed, 1 insertion(+)\n$ \n上述内容显示这次合并采用的是快速前进模式(fast forward),让我们看一下提交历史:\n$ git log --pretty=oneline --graph\n* 3fe94c0 (HEAD -> master, dev) fast forward\n*   22fbef7 git merge --no-ff dev\n|\\  \n| * 44d68f6 git checkout -b dev\n|/  \n*   3b8f434 fix conflict\n|\\  \n| * 0fe95f8 git commit c2\n* | 0949cc3 git commit c3\n|/  \n* 5c482cd git commit c1\n* 413a4d1 see https://snowdreams1006.github.io/git/usage/branch-overview.html\n* 9c30e50 learn git branch\n* b3d8193 (origin/master, origin/HEAD) see https://snowdreams1006.github.io/git/usage/remote-repository.html\n* 8e62564 add test.txt\n* 9b196aa Initial commit\n$ \n上述内容表明,此次合并并没有产生新的 commit ,只是更改下 HEAD 指向而已(HEAD -> master, dev).\n?\n同样,现在删除 dev 分支,再看一下提交历史:\n# 删除 dev 分支\n$ git branch -d dev\nDeleted branch dev (was 3fe94c0).\n# 查看提交历史\n$ git log --pretty=oneline --graph\n* 3fe94c0 (HEAD -> master) fast forward\n*   22fbef7 git merge --no-ff dev\n|\\  \n| * 44d68f6 git checkout -b dev\n|/  \n*   3b8f434 fix conflict\n|\\  \n| * 0fe95f8 git commit c2\n* | 0949cc3 git commit c3\n|/  \n* 5c482cd git commit c1\n* 413a4d1 see https://snowdreams1006.github.io/git/usage/branch-overview.html\n* 9c30e50 learn git branch\n* b3d8193 (origin/master, origin/HEAD) see https://snowdreams1006.github.io/git/usage/remote-repository.html\n* 8e62564 add test.txt\n* 9b196aa Initial commit\n$ \n?\n由此可见,快速前进模式一旦删除分支后就彻底丢失了分支的信息,即便是从提交历史中也找不到曾经存在的痕迹!\n分支策略\ngit 是分布式版本控制系统,同时鼓励大量使用分支,如此一来大量的分支该如何管理? 实际开发中,建议准从以下原则进行分支管理:\nmaster 分支作为主干分支,负责对外提供服务,要求稳定可靠,因为应该专人负责更新维护.\ndev 分支作为开发分支,取代 master 分支的开发地位,积累到一定产出时再合并到 master 分支.\nfeature 分支作为新功能分支,根据实际情况动态创建,删除分支,并适时合并到 dev 分支.\nbugFixed 分支作为修复特定 bug 分支,可能由 master 分支衍生而来,也可能由 dev 分支衍生等等,修复后及时合并到原分支.\ncustom 自定义分支,项目成员私有分支,由上级领导分配任务后各开发人员自行选择创建自己的分支,并根据实际情况决定合并到 dev 分支或 feature 等分支.\n?\n小结\n快速前进模式(git merge <name>)不保留分支合并历史,递归模式(git merge --no-ff -m <remark> <name>)保留分支合并历史.\n制定大家都认同的分支管理原则,并严格准守规则.\n     (adsbygoogle = window.adsbygoogle || []).push({});  ","brief":"\n默认情况下合并分支常常直接使用 git merge 命令,是最方便快速的合并方法.其实这种情况下 git 采用的是 fast forward 模式,特点是删除...","summary":"默认情况下合并分支常常直接使用 git merge 命令,是最方便快速的合并方法.其实这种情况下 git 采用的是 fast forward 模式,特点是删除分...","abstract":"默认情况下合并分支常常直接使用 git merge 命令,是最方便快速的合并方法.其实这种情况下 git 采用的是 fast forward 模式,特点是删除分...","description":"","picture":"https://ask.qcloudimg.com/http-save/yehe-2952369/zz2zjxddax.png","coverImageUrl":"https://ask.qcloudimg.com/http-save/yehe-2952369/zz2zjxddax.png","sourceType":99,"sourceDetail":{},"channelType":2,"channelDetail":{"source":"oschina","originalTime":"03/21 07:35"},"authorId":2952369,"columnId":75668,"writeTime":1554275691,"updateTime":1554275691,"viewCount":74,"likeCount":3,"commentCount":0,"weight":0,"status":2,"draftId":0,"tagIds":[],"tags":[{"tagId":10283,"tagName":"Git"}],"isCommentEnable":true,"column":{"id":75668,"name":"雪之梦技术驿站","desc":"雪之梦技术驿站又名snowdreams1006的技术小屋.主要分享个人的学习经验,一家之言,仅供参考.","icon":"https://ask.qcloudimg.com/column-icons/75668/2952369/rs2libapbs.png","background":"","status":2,"creatorId":2952369,"memberCount":1,"articleCount":67,"followCount":12,"createdTime":1553570025}}},{"id":2683,"type":40,"actionInfo":{"articleId":1409889,"columnId":75668,"articleOwnerUid":2952369},"createTime":1554275677,"detail":{"id":1409889,"articleId":1409889,"title":"git 入门教程之冲突合并\n                                                                            原","content":"entityMap|0|type|IMAGE|mutability|IMMUTABLE|data|imageUrl|https://ask.qcloudimg.com/http-save/yehe-2952369/uo7741jeaj.png|imageAlt|git-commit-c1.png|1|https://ask.qcloudimg.com/http-save/yehe-2952369/4u7eqbgyox.png|git-checkout-feature.png|2|https://ask.qcloudimg.com/http-save/yehe-2952369/t1mkf61o37.png|git-commit-c2.png|3|https://ask.qcloudimg.com/http-save/yehe-2952369/x5jofeivmy.png|git-checkout-master-c1.png|4|https://ask.qcloudimg.com/http-save/yehe-2952369/ssgvm6bumm.png|git-commit-c3.png|5|https://ask.qcloudimg.com/http-save/yehe-2952369/qstfazcldp.png|git-merge-with-conflict.png|blocks|key|4369c|text|unstyled|depth|inlineStyleRanges|entityRanges|2tntc|如果足够幸运的话,团队成员互不影响,彼此相安无事,大家各自基于+master+分支的某个+commit+创建自己的分支,平时在分支上独立工作,等到一段时间后再合并+merge+到+master+分支,这样一样+master+作为各个功能的集大成者,最终完成项目.|offset|length|style|CODE|bk7bp|然而事情总不是一帆风顺的,团队协作时由于意见不同,遇到冲突简直是家常便饭,既然无法回避冲突,当冲突发生时如何应该呢?|iv6f|背景|header-two|4ma3n|基于+master+分支上的某个+commit+,新功能由此继续开发:|d7653|echo+\"git+commit+c1\"+>>+test.txt\n$+git+add+test.txt\n$+git+commit+-m+\"git+commit+c1\"|code-block|syntax|javascript|6epkb|?|atomic|bj7an|新功能分支命名为+feature+,使用git+checkout+-b+<name>+创建分支并切换:|dsn82|$git+checkout+-b+feature\nSwitched+to+a+new+branch+'feature'\n$+|2r9k8|37pnl|在新功能+feature+分支上开发新功能,并提交:|32bqt|$+echo+\"git+commit+c2\"+>>+test.txt\n$+git+add+test.txt\n$+git+commit+-m+\"git+commit+c2\"\n[feature+0fe95f8]+git+commit+c2\n+1+file+changed,+1+insertion(%2B)\n$+|8vsol|1utdu|无论新功能+feature+是否开发完毕,团队的其他成员均有可能处于+master+分支并做相应更改:|20uib|$+git+checkout+master\nSwitched+to+branch+'master'\nYour+branch+is+ahead+of+'origin/master'+by+3+commits.\n++(use+\"git+push\"+to+publish+your+local+commits)|a7ado|533rq|其他成员对新功能有着自己的看法,于是也提交了版本,由于我们之前提交的是+git+commit+c2,而此时master+分支提交的是git+commit+c3,显然我们两个人的意见不一致!|90ifg|$+echo+\"git+commit+c3\"+>>+test.txt\n$+git+add+test.txt\n$+git+commit+-m+\"git+commit+c3\"\n[master+0949cc3]+git+commit+c3\n+1+file+changed,+1+insertion(%2B)\n$+|5saml|a39r7|正在此时,feature+分支的新功能已开发完毕并主动切换回+master+分支,准备合并+feature+分支.|3rpdr|#+合并+feature+分支\n$+git+merge+feature\nAuto-merging+test.txt\nCONFLICT+(content):+Merge+conflict+in+test.txt\nAutomatic+merge+failed;+fix+conflicts+and+then+commit+the+result.\n$|e7sue|由于项目成员沟通不畅或者意见不一致,导致了代码冲突,git+作为版本控制系统,自然无法解决这类问题,总不能擅自做主抛弃后来的更改吧或者抛弃分支更改?所以+git+只负责抛出问题,等待我们程序员去解决问题.|abuum|既然是人的问题,那我们看一下我们到底是哪里不一致,为什么会产生冲突?|bc8o|#+查看状态\n$+git+status\nOn+branch+master\nYour+branch+is+ahead+of+'origin/master'+by+4+commits.\n++(use+\"git+push\"+to+publish+your+local+commits)\n\nYou+have+unmerged+paths.\n++(fix+conflicts+and+run+\"git+commit\")\n++(use+\"git+merge+--abort\"+to+abort+the+merge)\n\nUnmerged+paths:\n++(use+\"git+add+<file>...\"+to+mark+resolution)\n\n++++both+modified:+++test.txt\n\nno+changes+added+to+commit+(use+\"git+add\"+and/or+\"git+commit+-a\")\n#+比较差异\n$+git+diff+\ndiff+--cc+test.txt\nindex+6e00f87,0f95fd7..0000000\n---+a/test.txt\n%2B%2B%2B+b/test.txt\n@@@+-3,4+-3,4+%2B3,8+@@@+see+https://snowdreams1006.github.io/gi\n++learn+git+branch\n++see+https://snowdreams1006.github.io/git/usage/branch-overview.html\n++git+commit+c1\n%2B%2B<<<<<<<+HEAD\n+%2Bgit+commit+c3\n%2B%2B=======\n%2B+git+commit+c2\n%2B%2B>>>>>>>+feature|4ovc7|和我们预期一样,test.txt+文件产生了冲突,当前+HEAD+指向的提交即+master+分支是+git+commit+c3+,而+feature+分支是+git+commit+c2,对于同一个文件的同一行内容发生不同的更改,git+不知道也不应该知道如何处理.|br6qr|#+查看内容\n$+cat+test.txt\nadd+test.txt\nsee+https://snowdreams1006.github.io/git/usage/remote-repository.html\nlearn+git+branch\nsee+https://snowdreams1006.github.io/git/usage/branch-overview.html\ngit+commit+c1\n<<<<<<<+HEAD\ngit+commit+c3\n=======\ngit+commit+c2\n>>>>>>>+feature|41did|git+用+<<<<<<<+标记一个分支冲突开始,=======+标记分支分割线,>>>>>>>+标记另一个分支结束.|5jrlb|经过冲突双方的讨论后,彼此间达成妥协,决定修改成git+commit+c2+and+c3+,修改后继续提交:|abo3h|#+编辑冲突文件,按照协商一致的内容修改文件\n$+vim+test.txt\n#+将冲突内容更改为+git+commit+c2+and+c3\n$+cat+test.txt\nadd+test.txt\nsee+https://snowdreams1006.github.io/git/usage/remote-repository.html\nlearn+git+branch\nsee+https://snowdreams1006.github.io/git/usage/branch-overview.html\ngit+commit+c1\ngit+commit+c2+and+c3\n$+git+add+test.txt\n$+git+commit+-m+\"fix+conflict\"\n[master+3b8f434]+fix+conflict|6jhrl|冲突已经解决,现在回顾一下提交历史,使用git+log+--graph+图形化展示提交历史:|bji4g|#+查看提交日志\n$+git+log+--pretty=oneline+--graph\n*+++3b8f434013caa8c27fade4c59d7aa2ee2c079636+(HEAD+->+master)+fix+conflict\n%7C\\++\n%7C+*+0fe95f871b371834d30ea17faa82f84b7d67672b+(feature)+git+commit+c2\n*+%7C+0949cc319e099d554795d03c69ee38923af00d6c+git+commit+c3\n%7C/++\n*+5c482cd9965b9dfd4f273b43b240ed7db66167a8+git+commit+c1\n*+413a4d1d2aab5ab85b6097d4b9f81cb5601c3b26+see+https://snowdreams1006.github.io/git/usage/branch-overview.html\n*+9c30e50248b773e38b032477a859e87abe7c1bb0+learn+git+branch\n*+b3d8193bbcb9f76c47e831e3e212f2405ae09f93+(origin/master,+origin/HEAD)+see+https://snowdreams1006.github.io/git/usage/remote-repository.html\n*+8e625640348a47ac922409a1ecb4c844385582aa+add+test.txt\n*+9b196aab5bc87eeb11709c9eef35fca283e05c61+Initial+commit\n$+|ai96l|1gte0|最后,删除新功能分支+feature+,不用的分支及时清理干净,需要时再创建分支.|btjt6|$+git+branch+-d+feature|1delt|小结|52kc9|无法杜绝冲突的发生,代码上的冲突本质上是人为因素造成的冲突.|unordered-list-item|sjbk|解决冲突需要有关双方协商解决,不可能独自解决冲突,除非你抛弃自我,完全以对方为准.|pi72|使用+git+log+--graph+命令可以图表化查看提交历史,抑或+git+log+--pretty=oneline+--graph|9v7um|+++++(adsbygoogle+=+window.adsbygoogle+%7C%7C+[]).push({});++^0|0|W|6|19|6|2A|5|2I|6|2X|6|0|0|0|3|6|H|6|0|0|0|1|0|0|9|7|K|M|0|0|0|1|1|0|5|7|0|0|0|1|2|0|6|7|Z|6|0|0|0|1|3|0|10|D|1H|6|1U|D|0|0|0|1|4|0|5|7|V|6|1A|7|0|0|Q|3|25|3|0|0|0|8|8|S|4|14|6|1F|D|1W|7|28|D|37|3|0|0|0|3|6|7|P|7|15|7|0|O|K|0|0|K|F|0|0|0|1|5|0|B|7|0|0|0|0|0|3|F|10|W|0^^$0|$1|$2|3|4|5|6|$7|8|9|A]]|B|$2|3|4|5|6|$7|C|9|D]]|E|$2|3|4|5|6|$7|F|9|G]]|H|$2|3|4|5|6|$7|I|9|J]]|K|$2|3|4|5|6|$7|L|9|M]]|N|$2|3|4|5|6|$7|O|9|P]]]|Q|@$R|S|T|-4|2|U|V|37|W|@]|X|@]|6|$]]|$R|Y|T|Z|2|U|V|38|W|@$10|39|11|3A|12|13]|$10|3B|11|3C|12|13]|$10|3D|11|3E|12|13]|$10|3F|11|3G|12|13]|$10|3H|11|3I|12|13]]|X|@]|6|$]]|$R|14|T|15|2|U|V|3J|W|@]|X|@]|6|$]]|$R|16|T|17|2|18|V|3K|W|@]|X|@]|6|$]]|$R|19|T|1A|2|U|V|3L|W|@$10|3M|11|3N|12|13]|$10|3O|11|3P|12|13]]|X|@]|6|$]]|$R|1B|T|1C|2|1D|V|3Q|W|@]|X|@]|6|$1E|1F]]|$R|1G|T|1H|2|1I|V|3R|W|@]|X|@$10|3S|11|3T|R|3U]]|6|$]]|$R|1J|T|1K|2|U|V|3V|W|@$10|3W|11|3X|12|13]|$10|3Y|11|3Z|12|13]]|X|@]|6|$]]|$R|1L|T|1M|2|1D|V|40|W|@]|X|@]|6|$1E|1F]]|$R|1N|T|1H|2|1I|V|41|W|@]|X|@$10|42|11|43|R|44]]|6|$]]|$R|1O|T|1P|2|U|V|45|W|@$10|46|11|47|12|13]]|X|@]|6|$]]|$R|1Q|T|1R|2|1D|V|48|W|@]|X|@]|6|$1E|1F]]|$R|1S|T|1H|2|1I|V|49|W|@]|X|@$10|4A|11|4B|R|4C]]|6|$]]|$R|1T|T|1U|2|U|V|4D|W|@$10|4E|11|4F|12|13]|$10|4G|11|4H|12|13]]|X|@]|6|$]]|$R|1V|T|1W|2|1D|V|4I|W|@]|X|@]|6|$1E|1F]]|$R|1X|T|1H|2|1I|V|4J|W|@]|X|@$10|4K|11|4L|R|4M]]|6|$]]|$R|1Y|T|1Z|2|U|V|4N|W|@$10|4O|11|4P|12|13]|$10|4Q|11|4R|12|13]|$10|4S|11|4T|12|13]]|X|@]|6|$]]|$R|20|T|21|2|1D|V|4U|W|@]|X|@]|6|$1E|1F]]|$R|22|T|1H|2|1I|V|4V|W|@]|X|@$10|4W|11|4X|R|4Y]]|6|$]]|$R|23|T|24|2|U|V|4Z|W|@$10|50|11|51|12|13]|$10|52|11|53|12|13]|$10|54|11|55|12|13]]|X|@]|6|$]]|$R|25|T|26|2|1D|V|56|W|@]|X|@]|6|$1E|1F]]|$R|27|T|28|2|U|V|57|W|@$10|58|11|59|12|13]|$10|5A|11|5B|12|13]]|X|@]|6|$]]|$R|29|T|2A|2|U|V|5C|W|@]|X|@]|6|$]]|$R|2B|T|2C|2|1D|V|5D|W|@]|X|@]|6|$1E|1F]]|$R|2D|T|2E|2|U|V|5E|W|@$10|5F|11|5G|12|13]|$10|5H|11|5I|12|13]|$10|5J|11|5K|12|13]|$10|5L|11|5M|12|13]|$10|5N|11|5O|12|13]|$10|5P|11|5Q|12|13]|$10|5R|11|5S|12|13]]|X|@]|6|$]]|$R|2F|T|2G|2|1D|V|5T|W|@]|X|@]|6|$1E|1F]]|$R|2H|T|2I|2|U|V|5U|W|@$10|5V|11|5W|12|13]|$10|5X|11|5Y|12|13]|$10|5Z|11|60|12|13]|$10|61|11|62|12|13]]|X|@]|6|$]]|$R|2J|T|2K|2|U|V|63|W|@$10|64|11|65|12|13]]|X|@]|6|$]]|$R|2L|T|2M|2|1D|V|66|W|@]|X|@]|6|$1E|1F]]|$R|2N|T|2O|2|U|V|67|W|@$10|68|11|69|12|13]]|X|@]|6|$]]|$R|2P|T|2Q|2|1D|V|6A|W|@]|X|@]|6|$1E|1F]]|$R|2R|T|1H|2|1I|V|6B|W|@]|X|@$10|6C|11|6D|R|6E]]|6|$]]|$R|2S|T|2T|2|U|V|6F|W|@$10|6G|11|6H|12|13]]|X|@]|6|$]]|$R|2U|T|2V|2|1D|V|6I|W|@]|X|@]|6|$1E|1F]]|$R|2W|T|2X|2|18|V|6J|W|@]|X|@]|6|$]]|$R|2Y|T|2Z|2|30|V|6K|W|@]|X|@]|6|$]]|$R|31|T|32|2|30|V|6L|W|@]|X|@]|6|$]]|$R|33|T|34|2|30|V|6M|W|@$10|6N|11|6O|12|13]|$10|6P|11|6Q|12|13]]|X|@]|6|$]]|$R|35|T|36|2|U|V|6R|W|@]|X|@]|6|$]]]]","plain":"\n如果足够幸运的话,团队成员互不影响,彼此相安无事,大家各自基于 master 分支的某个 commit 创建自己的分支,平时在分支上独立工作,等到一段时间后再合并 merge 到 master 分支,这样一样 master 作为各个功能的集大成者,最终完成项目.\n然而事情总不是一帆风顺的,团队协作时由于意见不同,遇到冲突简直是家常便饭,既然无法回避冲突,当冲突发生时如何应该呢?\n背景\n基于 master 分支上的某个 commit ,新功能由此继续开发:\necho \"git commit c1\" >> test.txt\n$ git add test.txt\n$ git commit -m \"git commit c1\"\n?\n新功能分支命名为 feature ,使用git checkout -b <name> 创建分支并切换:\n$git checkout -b feature\nSwitched to a new branch 'feature'\n$ \n?\n在新功能 feature 分支上开发新功能,并提交:\n$ echo \"git commit c2\" >> test.txt\n$ git add test.txt\n$ git commit -m \"git commit c2\"\n[feature 0fe95f8] git commit c2\n 1 file changed, 1 insertion(+)\n$ \n?\n无论新功能 feature 是否开发完毕,团队的其他成员均有可能处于 master 分支并做相应更改:\n$ git checkout master\nSwitched to branch 'master'\nYour branch is ahead of 'origin/master' by 3 commits.\n  (use \"git push\" to publish your local commits)\n?\n其他成员对新功能有着自己的看法,于是也提交了版本,由于我们之前提交的是 git commit c2,而此时master 分支提交的是git commit c3,显然我们两个人的意见不一致!\n$ echo \"git commit c3\" >> test.txt\n$ git add test.txt\n$ git commit -m \"git commit c3\"\n[master 0949cc3] git commit c3\n 1 file changed, 1 insertion(+)\n$ \n?\n正在此时,feature 分支的新功能已开发完毕并主动切换回 master 分支,准备合并 feature 分支.\n# 合并 feature 分支\n$ git merge feature\nAuto-merging test.txt\nCONFLICT (content): Merge conflict in test.txt\nAutomatic merge failed; fix conflicts and then commit the result.\n$\n由于项目成员沟通不畅或者意见不一致,导致了代码冲突,git 作为版本控制系统,自然无法解决这类问题,总不能擅自做主抛弃后来的更改吧或者抛弃分支更改?所以 git 只负责抛出问题,等待我们程序员去解决问题.\n既然是人的问题,那我们看一下我们到底是哪里不一致,为什么会产生冲突?\n# 查看状态\n$ git status\nOn branch master\nYour branch is ahead of 'origin/master' by 4 commits.\n  (use \"git push\" to publish your local commits)\n\nYou have unmerged paths.\n  (fix conflicts and run \"git commit\")\n  (use \"git merge --abort\" to abort the merge)\n\nUnmerged paths:\n  (use \"git add <file>...\" to mark resolution)\n\n    both modified:   test.txt\n\nno changes added to commit (use \"git add\" and/or \"git commit -a\")\n# 比较差异\n$ git diff \ndiff --cc test.txt\nindex 6e00f87,0f95fd7..0000000\n--- a/test.txt\n+++ b/test.txt\n@@@ -3,4 -3,4 +3,8 @@@ see https://snowdreams1006.github.io/gi\n  learn git branch\n  see https://snowdreams1006.github.io/git/usage/branch-overview.html\n  git commit c1\n++<<<<<<< HEAD\n +git commit c3\n++=======\n+ git commit c2\n++>>>>>>> feature\n和我们预期一样,test.txt 文件产生了冲突,当前 HEAD 指向的提交即 master 分支是 git commit c3 ,而 feature 分支是 git commit c2,对于同一个文件的同一行内容发生不同的更改,git 不知道也不应该知道如何处理.\n# 查看内容\n$ cat test.txt\nadd test.txt\nsee https://snowdreams1006.github.io/git/usage/remote-repository.html\nlearn git branch\nsee https://snowdreams1006.github.io/git/usage/branch-overview.html\ngit commit c1\n<<<<<<< HEAD\ngit commit c3\n=======\ngit commit c2\n>>>>>>> feature\ngit 用 <<<<<<< 标记一个分支冲突开始,======= 标记分支分割线,>>>>>>> 标记另一个分支结束.\n经过冲突双方的讨论后,彼此间达成妥协,决定修改成git commit c2 and c3 ,修改后继续提交:\n# 编辑冲突文件,按照协商一致的内容修改文件\n$ vim test.txt\n# 将冲突内容更改为 git commit c2 and c3\n$ cat test.txt\nadd test.txt\nsee https://snowdreams1006.github.io/git/usage/remote-repository.html\nlearn git branch\nsee https://snowdreams1006.github.io/git/usage/branch-overview.html\ngit commit c1\ngit commit c2 and c3\n$ git add test.txt\n$ git commit -m \"fix conflict\"\n[master 3b8f434] fix conflict\n冲突已经解决,现在回顾一下提交历史,使用git log --graph 图形化展示提交历史:\n# 查看提交日志\n$ git log --pretty=oneline --graph\n*   3b8f434013caa8c27fade4c59d7aa2ee2c079636 (HEAD -> master) fix conflict\n|\\  \n| * 0fe95f871b371834d30ea17faa82f84b7d67672b (feature) git commit c2\n* | 0949cc319e099d554795d03c69ee38923af00d6c git commit c3\n|/  \n* 5c482cd9965b9dfd4f273b43b240ed7db66167a8 git commit c1\n* 413a4d1d2aab5ab85b6097d4b9f81cb5601c3b26 see https://snowdreams1006.github.io/git/usage/branch-overview.html\n* 9c30e50248b773e38b032477a859e87abe7c1bb0 learn git branch\n* b3d8193bbcb9f76c47e831e3e212f2405ae09f93 (origin/master, origin/HEAD) see https://snowdreams1006.github.io/git/usage/remote-repository.html\n* 8e625640348a47ac922409a1ecb4c844385582aa add test.txt\n* 9b196aab5bc87eeb11709c9eef35fca283e05c61 Initial commit\n$ \n?\n最后,删除新功能分支 feature ,不用的分支及时清理干净,需要时再创建分支.\n$ git branch -d feature\n小结\n无法杜绝冲突的发生,代码上的冲突本质上是人为因素造成的冲突.\n解决冲突需要有关双方协商解决,不可能独自解决冲突,除非你抛弃自我,完全以对方为准.\n使用 git log --graph 命令可以图表化查看提交历史,抑或 git log --pretty=oneline --graph\n     (adsbygoogle = window.adsbygoogle || []).push({});  ","brief":"\n如果足够幸运的话,团队成员互不影响,彼此相安无事,大家各自基于 master 分支的某个 commit 创建自己的分支,平时在分支上独立工作,等到一段时间后再...","summary":"如果足够幸运的话,团队成员互不影响,彼此相安无事,大家各自基于 master 分支的某个 commit 创建自己的分支,平时在分支上独立工作,等到一段时间后再合...","abstract":"如果足够幸运的话,团队成员互不影响,彼此相安无事,大家各自基于 master 分支的某个 commit 创建自己的分支,平时在分支上独立工作,等到一段时间后再合...","description":"","picture":"https://ask.qcloudimg.com/http-save/yehe-2952369/uo7741jeaj.png","coverImageUrl":"https://ask.qcloudimg.com/http-save/yehe-2952369/uo7741jeaj.png","sourceType":99,"sourceDetail":{},"channelType":2,"channelDetail":{"source":"oschina","originalTime":"03/20 15:58"},"authorId":2952369,"columnId":75668,"writeTime":1554275677,"updateTime":1554275677,"viewCount":71,"likeCount":3,"commentCount":0,"weight":0,"status":2,"draftId":0,"tagIds":[],"tags":[{"tagId":10283,"tagName":"Git"}],"isCommentEnable":true,"column":{"id":75668,"name":"雪之梦技术驿站","desc":"雪之梦技术驿站又名snowdreams1006的技术小屋.主要分享个人的学习经验,一家之言,仅供参考.","icon":"https://ask.qcloudimg.com/column-icons/75668/2952369/rs2libapbs.png","background":"","status":2,"creatorId":2952369,"memberCount":1,"articleCount":67,"followCount":12,"createdTime":1553570025}}},{"id":2682,"type":40,"actionInfo":{"articleId":1409888,"columnId":75668,"articleOwnerUid":2952369},"createTime":1554275663,"detail":{"id":1409888,"articleId":1409888,"title":"git 入门教程之分支总览\n                                                                            原\n        ","content":"entityMap|0|type|IMAGE|mutability|IMMUTABLE|data|imageUrl|https://ask.qcloudimg.com/http-save/yehe-2952369/gkp9bjex7c.gif|imageAlt|git-commit.gif|1|https://ask.qcloudimg.com/http-save/yehe-2952369/ccowfdbcpx.gif|git-branch.gif|2|https://ask.qcloudimg.com/http-save/yehe-2952369/3jl00c9q0i.png|git-on-master.png|3|https://ask.qcloudimg.com/http-save/yehe-2952369/czau7fqgo1.png|git-on-dev.png|4|https://ask.qcloudimg.com/http-save/yehe-2952369/20l8db8n8d.png|git-on-dev-commit1.png|5|https://ask.qcloudimg.com/http-save/yehe-2952369/mrfpo5ymzb.png|git-on-dev-commit2.png|6|https://ask.qcloudimg.com/http-save/yehe-2952369/8nfcr476z5.png|git-checkout-master.png|7|https://ask.qcloudimg.com/http-save/yehe-2952369/y5ms7lzz65.png|git-merge-dev.png|8|https://ask.qcloudimg.com/http-save/yehe-2952369/5e5g72vv9x.png|git-branch-d-dev.png|blocks|key|ehkoq|text|unstyled|depth|inlineStyleRanges|entityRanges|3e0kt|分支就是一条独立的时间线,既有分支,必有主干,正如一棵树谈到树枝,必有树干一样的道理.我们先前对git+的全部操作默认都是在主干上进行的,这个主干也是一种特殊的分支,名为+master+分支.|offset|length|style|CODE|9tekv|无论是穿越历史还是撤销更改,我们都或多或少接触过时间线,git+管理的版本串在一起就组成了这个时间线,其中master+分支是当前分支,HEAD+指向master+,因此HEAD+相当于指向了最新的版本.|2u2b8|?|atomic|dugve|基于分支上的操作,每一次+commit+都会提交一个新版本,并且新的+commit+指向原来的+commit,这来最新的+commit+就可以往前找,直到找到最初的commit.这就是+git+的时间线.|du6qr|当我们打算开辟新的时间线时,git+在当前+HEAD+指向的+master+分支的+commit+处新建一个+dev+分支.如果主角没有主动进入时间线的话,那么仍然处于+master+分支,进入的方法就是+HEAD指向新建的+dev+分支.|8t9fb|不考虑孙悟空的分身特效,主角不能同时处于不同的时空下,git+也是如何,HEAD+只能指向某一个+commit+,既然刚刚已经指向了+dev+分支,所以原来的+master+分支就没有+HEAD+了,因为相当于master+分支静止了.|fmiu5|当主角在+dev+分支独自闯荡干出一番事业时,决定回到故乡+master+分支,并将出门在外所学的本领带回家乡,建设美好家园.master+分支因为合并了+dev+分支,所以一下子增添了很多内容,家乡焕然一新!|dbiof|主角这次携带+dev+分支归来,HEAD+分支自然又回到了+master+分支上,年轻的心向往外面的世间,相信不久后还会有同样的故事发生...|debqa|9ov9u|下面详解分支相关命令|7liqe|创建分支|header-two|2o535|创建+dev+分支,列出分支已验证是否创建成功|cdsib|#+创建分支\n$git+branch+dev\n#+列出分支\n$+git+branch\n++dev\n*+master\n$+|code-block|syntax|javascript|8lfk2|+*+master+前面的+*+标记表明当前仍然处于+master+分支\n+|blockquote|ampeu|apm96|切换分支|3fn11|切换到新分支以便在分支上开展工作|4ebgv|#+切换分支\n$+git+checkout+dev\nSwitched+to+branch+'dev'\n#+列出分支\n$+git+branch\n*+dev\n++master\n$|24b6l|edtrc|现在,我们在+dev+分支上奋笔疾书,先后提交两个版本后完成分支开发工作:|9gns9|#+查看当前文件列表\n$+ls\nLICENSE+++++README.md+++test.txt\n#+查看目标文件内容\n$+cat+test.txt\nadd+test.txt\nsee+https://snowdreams1006.github.io/git/usage/remote-repository.html\n\n#+第一个版本:+learn+git+branch\n$+echo+\"learn+git+branch\"+>>+test.txt\n$+git+add+test.txt\n$+git+commit+-m+\"learn+git+branch\"\n[dev+9c30e50]+learn+git+branch\n+1+file+changed,+1+insertion(%2B)\n\n#+第二个版本:+see+https://snowdreams1006.github.io/git/usage/branch-overview.html\n$+echo+\"see+https://snowdreams1006.github.io/git/usage/branch-overview.html\"+>>+test.txt\n$+git+add+test.txt\nsunpodeMacBook-Pro:git-demo+sunpo$+git+status\nOn+branch+dev\nChanges+to+be+committed:\n++(use+\"git+reset+HEAD+<file>...\"+to+unstage)\n\n++++modified:+++test.txt\n\n$+git+commit+-m+\"see+https://snowdreams1006.github.io/git/usage/branch-overview.html\"\n[dev+413a4d1]+see+https://snowdreams1006.github.io/git/usage/branch-overview.html\n+1+file+changed,+1+insertion(%2B)|6mu7q|b5ooe|b010b|此时,再从+dev+分支切换回+master+分支,合并dev分支前看一下当前文件内容:|7fn7e|#+切换回+master+分支\n$+git+checkout+master\nSwitched+to+branch+'master'\nYour+branch+is+up+to+date+with+'origin/master'.\nsunpodeMacBook-Pro:git-demo+sunpo$+git+status\nOn+branch+master\nYour+branch+is+up+to+date+with+'origin/master'.\n\nnothing+to+commit,+working+tree+clean\n#+查看当前文件列表\n$+ls\nLICENSE+++++README.md+++test.txt\n#+查看文件内容:+无+dev+分支更改\n$+cat+test.txt\nadd+test.txt\nsee+https://snowdreams1006.github.io/git/usage/remote-repository.html\n$+|1ffqv|2h6as|合并分支|1mq3c|切换回+master+分支并没有我们在+dev+分支的更改,因为两条时间线是独立的,现在合并+dev+分支,再看一下当前文件内容:|durth|#+合并+dev+分支\n$+git+merge+dev\nUpdating+b3d8193..413a4d1\nFast-forward\n+test.txt+%7C+2+%2B%2B\n+1+file+changed,+2+insertions(%2B)\n#+查看文件内容:+已经存在+dev+分支的更改!\n$+cat+test.txt\nadd+test.txt\nsee+https://snowdreams1006.github.io/git/usage/remote-repository.html\nlearn+git+branch\nsee+https://snowdreams1006.github.io/git/|2sbcu|b5oeq|删除分支|3bmr6|合并分支后,dev+分支的历史使命已经完成,应该及时清空不必要分支.|bq5kc|#+删除+dev+分支\n$+git+branch+-d+dev\nDeleted+branch+dev+(was+413a4d1).\n\n#+列出当前分支:+只剩下+master+分支\n$+git+branch\n*+master\n$+|7bhb7|c1p5c|以上场景包括了分支的常用操作,创建分支(git+branch+<name>),切换分支(git+checkout+<name>),删除分支(git+branch+-d+<name>)一系列操作十分流畅,因此+git+鼓励我们大量使用分支!|7ko02|小结|dpgos|列出分支+git+branch|unordered-list-item|1f40r|创建分支+git+branch+<name>|fjc0o|切换分支+git+checkout+<name>|68t4h|创建并切换分支+git+checkout+-b+<name>|adbv8|合并指定分支到当前分支+git+merge+<name>|fqmf6|删除分支+git+branch+-d+<name>|1bceo|+++++(adsbygoogle+=+window.adsbygoogle+%7C%7C+[]).push({});++^0|0|1C|3|2E|6|0|S|3|1H|6|1W|4|23|6|2D|4|0|0|1|0|0|D|6|Z|6|1C|6|1P|6|2A|6|2L|3|0|E|3|M|4|V|6|16|6|1J|3|2D|6|2V|4|35|3|0|R|3|10|4|1D|6|1V|3|28|6|2L|4|2X|6|0|5|3|U|6|1R|6|26|3|0|7|3|G|4|U|6|0|0|1|1|0|0|0|3|3|0|0|3|6|R|6|0|0|1|2|0|0|0|0|0|1|3|0|7|3|0|0|0|1|4|0|0|1|5|0|6|3|G|6|S|3|0|0|0|1|6|0|0|4|6|K|3|1B|3|0|0|0|1|7|0|0|6|3|0|0|0|1|8|0|K|H|18|J|1Y|K|2W|3|0|0|5|A|0|5|H|0|5|J|0|8|M|0|C|G|0|5|K|0^^$0|$1|$2|3|4|5|6|$7|8|9|A]]|B|$2|3|4|5|6|$7|C|9|D]]|E|$2|3|4|5|6|$7|F|9|G]]|H|$2|3|4|5|6|$7|I|9|J]]|K|$2|3|4|5|6|$7|L|9|M]]|N|$2|3|4|5|6|$7|O|9|P]]|Q|$2|3|4|5|6|$7|R|9|S]]|T|$2|3|4|5|6|$7|U|9|V]]|W|$2|3|4|5|6|$7|X|9|Y]]]|Z|@$10|11|12|-4|2|13|14|3O|15|@]|16|@]|6|$]]|$10|17|12|18|2|13|14|3P|15|@$19|3Q|1A|3R|1B|1C]|$19|3S|1A|3T|1B|1C]]|16|@]|6|$]]|$10|1D|12|1E|2|13|14|3U|15|@$19|3V|1A|3W|1B|1C]|$19|3X|1A|3Y|1B|1C]|$19|3Z|1A|40|1B|1C]|$19|41|1A|42|1B|1C]|$19|43|1A|44|1B|1C]]|16|@]|6|$]]|$10|1F|12|1G|2|1H|14|45|15|@]|16|@$19|46|1A|47|10|48]]|6|$]]|$10|1I|12|1J|2|13|14|49|15|@$19|4A|1A|4B|1B|1C]|$19|4C|1A|4D|1B|1C]|$19|4E|1A|4F|1B|1C]|$19|4G|1A|4H|1B|1C]|$19|4I|1A|4J|1B|1C]|$19|4K|1A|4L|1B|1C]]|16|@]|6|$]]|$10|1K|12|1L|2|13|14|4M|15|@$19|4N|1A|4O|1B|1C]|$19|4P|1A|4Q|1B|1C]|$19|4R|1A|4S|1B|1C]|$19|4T|1A|4U|1B|1C]|$19|4V|1A|4W|1B|1C]|$19|4X|1A|4Y|1B|1C]|$19|4Z|1A|50|1B|1C]|$19|51|1A|52|1B|1C]]|16|@]|6|$]]|$10|1M|12|1N|2|13|14|53|15|@$19|54|1A|55|1B|1C]|$19|56|1A|57|1B|1C]|$19|58|1A|59|1B|1C]|$19|5A|1A|5B|1B|1C]|$19|5C|1A|5D|1B|1C]|$19|5E|1A|5F|1B|1C]|$19|5G|1A|5H|1B|1C]]|16|@]|6|$]]|$10|1O|12|1P|2|13|14|5I|15|@$19|5J|1A|5K|1B|1C]|$19|5L|1A|5M|1B|1C]|$19|5N|1A|5O|1B|1C]|$19|5P|1A|5Q|1B|1C]]|16|@]|6|$]]|$10|1Q|12|1R|2|13|14|5R|15|@$19|5S|1A|5T|1B|1C]|$19|5U|1A|5V|1B|1C]|$19|5W|1A|5X|1B|1C]]|16|@]|6|$]]|$10|1S|12|1G|2|1H|14|5Y|15|@]|16|@$19|5Z|1A|60|10|61]]|6|$]]|$10|1T|12|1U|2|13|14|62|15|@]|16|@]|6|$]]|$10|1V|12|1W|2|1X|14|63|15|@]|16|@]|6|$]]|$10|1Y|12|1Z|2|13|14|64|15|@$19|65|1A|66|1B|1C]]|16|@]|6|$]]|$10|20|12|21|2|22|14|67|15|@]|16|@]|6|$23|24]]|$10|25|12|26|2|27|14|68|15|@$19|69|1A|6A|1B|1C]|$19|6B|1A|6C|1B|1C]]|16|@]|6|$]]|$10|28|12|1G|2|1H|14|6D|15|@]|16|@$19|6E|1A|6F|10|6G]]|6|$]]|$10|29|12|2A|2|1X|14|6H|15|@]|16|@]|6|$]]|$10|2B|12|2C|2|13|14|6I|15|@]|16|@]|6|$]]|$10|2D|12|2E|2|22|14|6J|15|@]|16|@]|6|$23|24]]|$10|2F|12|1G|2|1H|14|6K|15|@]|16|@$19|6L|1A|6M|10|6N]]|6|$]]|$10|2G|12|2H|2|13|14|6O|15|@$19|6P|1A|6Q|1B|1C]]|16|@]|6|$]]|$10|2I|12|2J|2|22|14|6R|15|@]|16|@]|6|$23|24]]|$10|2K|12|1G|2|1H|14|6S|15|@]|16|@$19|6T|1A|6U|10|6V]]|6|$]]|$10|2L|12|1G|2|1H|14|6W|15|@]|16|@$19|6X|1A|6Y|10|6Z]]|6|$]]|$10|2M|12|2N|2|13|14|70|15|@$19|71|1A|72|1B|1C]|$19|73|1A|74|1B|1C]|$19|75|1A|76|1B|1C]]|16|@]|6|$]]|$10|2O|12|2P|2|22|14|77|15|@]|16|@]|6|$23|24]]|$10|2Q|12|1G|2|1H|14|78|15|@]|16|@$19|79|1A|7A|10|7B]]|6|$]]|$10|2R|12|2S|2|1X|14|7C|15|@]|16|@]|6|$]]|$10|2T|12|2U|2|13|14|7D|15|@$19|7E|1A|7F|1B|1C]|$19|7G|1A|7H|1B|1C]|$19|7I|1A|7J|1B|1C]]|16|@]|6|$]]|$10|2V|12|2W|2|22|14|7K|15|@]|16|@]|6|$23|24]]|$10|2X|12|1G|2|1H|14|7L|15|@]|16|@$19|7M|1A|7N|10|7O]]|6|$]]|$10|2Y|12|2Z|2|1X|14|7P|15|@]|16|@]|6|$]]|$10|30|12|31|2|13|14|7Q|15|@$19|7R|1A|7S|1B|1C]]|16|@]|6|$]]|$10|32|12|33|2|22|14|7T|15|@]|16|@]|6|$23|24]]|$10|34|12|1G|2|1H|14|7U|15|@]|16|@$19|7V|1A|7W|10|7X]]|6|$]]|$10|35|12|36|2|13|14|7Y|15|@$19|7Z|1A|80|1B|1C]|$19|81|1A|82|1B|1C]|$19|83|1A|84|1B|1C]|$19|85|1A|86|1B|1C]]|16|@]|6|$]]|$10|37|12|38|2|1X|14|87|15|@]|16|@]|6|$]]|$10|39|12|3A|2|3B|14|88|15|@$19|89|1A|8A|1B|1C]]|16|@]|6|$]]|$10|3C|12|3D|2|3B|14|8B|15|@$19|8C|1A|8D|1B|1C]]|16|@]|6|$]]|$10|3E|12|3F|2|3B|14|8E|15|@$19|8F|1A|8G|1B|1C]]|16|@]|6|$]]|$10|3G|12|3H|2|3B|14|8H|15|@$19|8I|1A|8J|1B|1C]]|16|@]|6|$]]|$10|3I|12|3J|2|3B|14|8K|15|@$19|8L|1A|8M|1B|1C]]|16|@]|6|$]]|$10|3K|12|3L|2|3B|14|8N|15|@$19|8O|1A|8P|1B|1C]]|16|@]|6|$]]|$10|3M|12|3N|2|13|14|8Q|15|@]|16|@]|6|$]]]]","plain":"\n分支就是一条独立的时间线,既有分支,必有主干,正如一棵树谈到树枝,必有树干一样的道理.我们先前对git 的全部操作默认都是在主干上进行的,这个主干也是一种特殊的分支,名为 master 分支.\n无论是穿越历史还是撤销更改,我们都或多或少接触过时间线,git 管理的版本串在一起就组成了这个时间线,其中master 分支是当前分支,HEAD 指向master ,因此HEAD 相当于指向了最新的版本.\n?\n基于分支上的操作,每一次 commit 都会提交一个新版本,并且新的 commit 指向原来的 commit,这来最新的 commit 就可以往前找,直到找到最初的commit.这就是 git 的时间线.\n当我们打算开辟新的时间线时,git 在当前 HEAD 指向的 master 分支的 commit 处新建一个 dev 分支.如果主角没有主动进入时间线的话,那么仍然处于 master 分支,进入的方法就是 HEAD指向新建的 dev 分支.\n不考虑孙悟空的分身特效,主角不能同时处于不同的时空下,git 也是如何,HEAD 只能指向某一个 commit ,既然刚刚已经指向了 dev 分支,所以原来的 master 分支就没有 HEAD 了,因为相当于master 分支静止了.\n当主角在 dev 分支独自闯荡干出一番事业时,决定回到故乡 master 分支,并将出门在外所学的本领带回家乡,建设美好家园.master 分支因为合并了 dev 分支,所以一下子增添了很多内容,家乡焕然一新!\n主角这次携带 dev 分支归来,HEAD 分支自然又回到了 master 分支上,年轻的心向往外面的世间,相信不久后还会有同样的故事发生...\n?\n下面详解分支相关命令\n创建分支\n创建 dev 分支,列出分支已验证是否创建成功\n# 创建分支\n$git branch dev\n# 列出分支\n$ git branch\n  dev\n* master\n$ \n * master 前面的 * 标记表明当前仍然处于 master 分支\n \n?\n切换分支\n切换到新分支以便在分支上开展工作\n# 切换分支\n$ git checkout dev\nSwitched to branch 'dev'\n# 列出分支\n$ git branch\n* dev\n  master\n$\n?\n现在,我们在 dev 分支上奋笔疾书,先后提交两个版本后完成分支开发工作:\n# 查看当前文件列表\n$ ls\nLICENSE     README.md   test.txt\n# 查看目标文件内容\n$ cat test.txt\nadd test.txt\nsee https://snowdreams1006.github.io/git/usage/remote-repository.html\n\n# 第一个版本: learn git branch\n$ echo \"learn git branch\" >> test.txt\n$ git add test.txt\n$ git commit -m \"learn git branch\"\n[dev 9c30e50] learn git branch\n 1 file changed, 1 insertion(+)\n\n# 第二个版本: see https://snowdreams1006.github.io/git/usage/branch-overview.html\n$ echo \"see https://snowdreams1006.github.io/git/usage/branch-overview.html\" >> test.txt\n$ git add test.txt\nsunpodeMacBook-Pro:git-demo sunpo$ git status\nOn branch dev\nChanges to be committed:\n  (use \"git reset HEAD <file>...\" to unstage)\n\n    modified:   test.txt\n\n$ git commit -m \"see https://snowdreams1006.github.io/git/usage/branch-overview.html\"\n[dev 413a4d1] see https://snowdreams1006.github.io/git/usage/branch-overview.html\n 1 file changed, 1 insertion(+)\n?\n?\n此时,再从 dev 分支切换回 master 分支,合并dev分支前看一下当前文件内容:\n# 切换回 master 分支\n$ git checkout master\nSwitched to branch 'master'\nYour branch is up to date with 'origin/master'.\nsunpodeMacBook-Pro:git-demo sunpo$ git status\nOn branch master\nYour branch is up to date with 'origin/master'.\n\nnothing to commit, working tree clean\n# 查看当前文件列表\n$ ls\nLICENSE     README.md   test.txt\n# 查看文件内容: 无 dev 分支更改\n$ cat test.txt\nadd test.txt\nsee https://snowdreams1006.github.io/git/usage/remote-repository.html\n$ \n?\n合并分支\n切换回 master 分支并没有我们在 dev 分支的更改,因为两条时间线是独立的,现在合并 dev 分支,再看一下当前文件内容:\n# 合并 dev 分支\n$ git merge dev\nUpdating b3d8193..413a4d1\nFast-forward\n test.txt | 2 ++\n 1 file changed, 2 insertions(+)\n# 查看文件内容: 已经存在 dev 分支的更改!\n$ cat test.txt\nadd test.txt\nsee https://snowdreams1006.github.io/git/usage/remote-repository.html\nlearn git branch\nsee https://snowdreams1006.github.io/git/\n?\n删除分支\n合并分支后,dev 分支的历史使命已经完成,应该及时清空不必要分支.\n# 删除 dev 分支\n$ git branch -d dev\nDeleted branch dev (was 413a4d1).\n\n# 列出当前分支: 只剩下 master 分支\n$ git branch\n* master\n$ \n?\n以上场景包括了分支的常用操作,创建分支(git branch <name>),切换分支(git checkout <name>),删除分支(git branch -d <name>)一系列操作十分流畅,因此 git 鼓励我们大量使用分支!\n小结\n列出分支 git branch\n创建分支 git branch <name>\n切换分支 git checkout <name>\n创建并切换分支 git checkout -b <name>\n合并指定分支到当前分支 git merge <name>\n删除分支 git branch -d <name>\n     (adsbygoogle = window.adsbygoogle || []).push({});  ","brief":"\n分支就是一条独立的时间线,既有分支,必有主干,正如一棵树谈到树枝,必有树干一样的道理.我们先前对git 的全部操作默认都是在主干上进行的,这个主干也是一种特殊...","summary":"分支就是一条独立的时间线,既有分支,必有主干,正如一棵树谈到树枝,必有树干一样的道理.我们先前对git 的全部操作默认都是在主干上进行的,这个主干也是一种特殊的...","abstract":"分支就是一条独立的时间线,既有分支,必有主干,正如一棵树谈到树枝,必有树干一样的道理.我们先前对git 的全部操作默认都是在主干上进行的,这个主干也是一种特殊的...","description":"","picture":"https://ask.qcloudimg.com/http-save/yehe-2952369/gkp9bjex7c.gif","coverImageUrl":"https://ask.qcloudimg.com/http-save/yehe-2952369/gkp9bjex7c.gif","sourceType":99,"sourceDetail":{},"channelType":2,"channelDetail":{"source":"oschina","originalTime":"03/19 10:23"},"authorId":2952369,"columnId":75668,"writeTime":1554275663,"updateTime":1554275663,"viewCount":92,"likeCount":6,"commentCount":0,"weight":0,"status":2,"draftId":0,"tagIds":[],"tags":[{"tagId":10283,"tagName":"Git"}],"isCommentEnable":true,"column":{"id":75668,"name":"雪之梦技术驿站","desc":"雪之梦技术驿站又名snowdreams1006的技术小屋.主要分享个人的学习经验,一家之言,仅供参考.","icon":"https://ask.qcloudimg.com/column-icons/75668/2952369/rs2libapbs.png","background":"","status":2,"creatorId":2952369,"memberCount":1,"articleCount":67,"followCount":12,"createdTime":1553570025}}},{"id":2681,"type":40,"actionInfo":{"articleId":1409886,"columnId":75668,"articleOwnerUid":2952369},"createTime":1554275489,"detail":{"id":1409886,"articleId":1409886,"title":"git 入门教程之分支管理\n                                                                            原","content":"entityMap|blocks|key|1fgn9|text|type|unstyled|depth|inlineStyleRanges|entityRanges|data|fi5pb|什么是分支?简单地说,分支就是两个相对独立的时间线,正常情况下,独立的时间线永远不会有交集,彼此不知道对方的存在,只有特定情况下,两条时间线才会相遇,因为相遇,所以相知,因为相知,所以改变!|87da2|正如分支对于科幻电影来说是一个很好的卖点,关于分支的话题完全可以开启新的题材,对于这点相信不少科幻迷都深有体会,不必赘述.|3q496|回归正题,分支对于版本控制系统又意味着什么呢?实际工作中,我们大多作为一个团队一起合作开发项目,如果是独立开发者,只有一个人的话,其实用不到分支的概念,甚至远程仓库也用不到.所以下述情况针对的都是团队开发情况.|7893r|作为团队中的一员不论是项目领导还是项目成员,都需要了解并掌握分支的一般概念和常用操作.如果你刚好是实际开发的程序猿,上级领导分派一个新功能,预期两个星期内才能完成,其他同事也是如此,每个人都有自己的任务.接收任务就要开始干活,第一天工作开了一个头,还留下一大堆的+TODO+标记,此时你照例运行+git+add+,git+commit+等命令,学会上节的git+push+origin+master+你知道了本地仓库和远程仓库的概念,你想将你的工作成果分享给其他人就要推送到远程仓库,这样其他人才能可见,等一等,别急!|offset|length|style|CODE|de5h3|首先明确的是,这个完整功能至少需要2个星期才能基本完成啊,你现在刚刚起了个头还没完成呢!你要是真的推送到远程仓库了,那其他人是不是有理由认为你这部分功能已完成?那你可能会反驳说,我可以在工作群吼一声,说这个功能还没完成,大家别着急使用哈!这样确实可以,很长一段时间内其他人必须无视你的代码,只有等你的功能基本可用时,等你再吼一声,别人才会去使用你的代码.粗略一看,好像并没有什么问题?!|blvkm|实际上这种情况是存在很大风险的,因为未完成未经过测试的代码可能会产生大量意外+bug,严重的话,甚至影响整个系统,到时候由于你的未完成代码导致别人项目都无法运行,那别人还怎么工作,这个责任是谁负责?|8nf71|所以,为了不给其他人造成麻烦,最好不要把未完成工作直接暴露到别人面前,那长时间提交又可能会造成丢失更改的风险,此时此景,平行时间线应用而生!|9i62h|从接手新功能的时间点开始,创建一条新的时间线,于是新功能的开发完全在新的时间线上进行,至于其他人是否开启新的时间线那就不是我们能控制得了,我们能做到的就是不给其他人制造麻烦,如果其他人给我们制造麻烦的话,那我们就去上级领导那告他一状,哈哈!|ej3el|等功能开发差不多时,你再想办法切换到原来的时间线上并将开发时间线的更改顺便都带过来,这样一来,别人虽然看不到你的开发时间线,但是看到了你离开的这段时间原来做了这么多的更改啊!|9dbn1|现在用git的专业术语再解释一遍上述场景:|ef7g5|接手新功能的时刻开始,创建一个开发分支(既可以是本地分支也可以是远程分支),以后新功能的开发全部在开发分支上完成,处于开发分支上你可以照常运行+git+add+,git+commit+等命令,不用担心丢失更改.等工作一段时间后,终于完成了新功能,是时候让新功能展示给其他同事了.此时再切换到原来的主干分支,在主干分支上合并开发分支,现在主干分支上已经有新功能了,这样一来,其他同事突然发现你已经偷偷地完成了新功能的开发!|4sqio|不仅+git+有分支概念,其他版本控制系统比如+svn+也有分支概念,基本概念和常用操作类似,只不过+git+更强大,创建分支,切换分支,合并分支等功能十分强大,效率太高!+(svn+创建分支,切换分支等操作简直慢到可以喝一杯茶了,分支管理都快成摆设了!)|7jff1|建议|header-two|5iv9o|开发新功能时尽量创建自己的分支,不要给其他人造成麻烦|unordered-list-item|2uiau|分配任务时要求项目成员创建各自分支,等时机成熟时再合并到主干分支|6r3vr|+++++(adsbygoogle+=+window.adsbygoogle+%7C%7C+[]).push({});++^0|0|0|0|0|3O|4|44|7|4D|A|4X|M|0|0|0|0|0|0|3|3|0|20|7|29|A|0|3|3|O|3|1F|3|2G|3|0|0|0|0^^$0|$]|1|@$2|3|4|-4|5|6|7|1D|8|@]|9|@]|A|$]]|$2|B|4|C|5|6|7|1E|8|@]|9|@]|A|$]]|$2|D|4|E|5|6|7|1F|8|@]|9|@]|A|$]]|$2|F|4|G|5|6|7|1G|8|@]|9|@]|A|$]]|$2|H|4|I|5|6|7|1H|8|@$J|1I|K|1J|L|M]|$J|1K|K|1L|L|M]|$J|1M|K|1N|L|M]|$J|1O|K|1P|L|M]]|9|@]|A|$]]|$2|N|4|O|5|6|7|1Q|8|@]|9|@]|A|$]]|$2|P|4|Q|5|6|7|1R|8|@]|9|@]|A|$]]|$2|R|4|S|5|6|7|1S|8|@]|9|@]|A|$]]|$2|T|4|U|5|6|7|1T|8|@]|9|@]|A|$]]|$2|V|4|W|5|6|7|1U|8|@]|9|@]|A|$]]|$2|X|4|Y|5|6|7|1V|8|@$J|1W|K|1X|L|M]]|9|@]|A|$]]|$2|Z|4|10|5|6|7|1Y|8|@$J|1Z|K|20|L|M]|$J|21|K|22|L|M]]|9|@]|A|$]]|$2|11|4|12|5|6|7|23|8|@$J|24|K|25|L|M]|$J|26|K|27|L|M]|$J|28|K|29|L|M]|$J|2A|K|2B|L|M]]|9|@]|A|$]]|$2|13|4|14|5|15|7|2C|8|@]|9|@]|A|$]]|$2|16|4|17|5|18|7|2D|8|@]|9|@]|A|$]]|$2|19|4|1A|5|18|7|2E|8|@]|9|@]|A|$]]|$2|1B|4|1C|5|6|7|2F|8|@]|9|@]|A|$]]]]","plain":"\n什么是分支?简单地说,分支就是两个相对独立的时间线,正常情况下,独立的时间线永远不会有交集,彼此不知道对方的存在,只有特定情况下,两条时间线才会相遇,因为相遇,所以相知,因为相知,所以改变!\n正如分支对于科幻电影来说是一个很好的卖点,关于分支的话题完全可以开启新的题材,对于这点相信不少科幻迷都深有体会,不必赘述.\n回归正题,分支对于版本控制系统又意味着什么呢?实际工作中,我们大多作为一个团队一起合作开发项目,如果是独立开发者,只有一个人的话,其实用不到分支的概念,甚至远程仓库也用不到.所以下述情况针对的都是团队开发情况.\n作为团队中的一员不论是项目领导还是项目成员,都需要了解并掌握分支的一般概念和常用操作.如果你刚好是实际开发的程序猿,上级领导分派一个新功能,预期两个星期内才能完成,其他同事也是如此,每个人都有自己的任务.接收任务就要开始干活,第一天工作开了一个头,还留下一大堆的 TODO 标记,此时你照例运行 git add ,git commit 等命令,学会上节的git push origin master 你知道了本地仓库和远程仓库的概念,你想将你的工作成果分享给其他人就要推送到远程仓库,这样其他人才能可见,等一等,别急!\n首先明确的是,这个完整功能至少需要2个星期才能基本完成啊,你现在刚刚起了个头还没完成呢!你要是真的推送到远程仓库了,那其他人是不是有理由认为你这部分功能已完成?那你可能会反驳说,我可以在工作群吼一声,说这个功能还没完成,大家别着急使用哈!这样确实可以,很长一段时间内其他人必须无视你的代码,只有等你的功能基本可用时,等你再吼一声,别人才会去使用你的代码.粗略一看,好像并没有什么问题?!\n实际上这种情况是存在很大风险的,因为未完成未经过测试的代码可能会产生大量意外 bug,严重的话,甚至影响整个系统,到时候由于你的未完成代码导致别人项目都无法运行,那别人还怎么工作,这个责任是谁负责?\n所以,为了不给其他人造成麻烦,最好不要把未完成工作直接暴露到别人面前,那长时间提交又可能会造成丢失更改的风险,此时此景,平行时间线应用而生!\n从接手新功能的时间点开始,创建一条新的时间线,于是新功能的开发完全在新的时间线上进行,至于其他人是否开启新的时间线那就不是我们能控制得了,我们能做到的就是不给其他人制造麻烦,如果其他人给我们制造麻烦的话,那我们就去上级领导那告他一状,哈哈!\n等功能开发差不多时,你再想办法切换到原来的时间线上并将开发时间线的更改顺便都带过来,这样一来,别人虽然看不到你的开发时间线,但是看到了你离开的这段时间原来做了这么多的更改啊!\n现在用git的专业术语再解释一遍上述场景:\n接手新功能的时刻开始,创建一个开发分支(既可以是本地分支也可以是远程分支),以后新功能的开发全部在开发分支上完成,处于开发分支上你可以照常运行 git add ,git commit 等命令,不用担心丢失更改.等工作一段时间后,终于完成了新功能,是时候让新功能展示给其他同事了.此时再切换到原来的主干分支,在主干分支上合并开发分支,现在主干分支上已经有新功能了,这样一来,其他同事突然发现你已经偷偷地完成了新功能的开发!\n不仅 git 有分支概念,其他版本控制系统比如 svn 也有分支概念,基本概念和常用操作类似,只不过 git 更强大,创建分支,切换分支,合并分支等功能十分强大,效率太高! (svn 创建分支,切换分支等操作简直慢到可以喝一杯茶了,分支管理都快成摆设了!)\n建议\n开发新功能时尽量创建自己的分支,不要给其他人造成麻烦\n分配任务时要求项目成员创建各自分支,等时机成熟时再合并到主干分支\n     (adsbygoogle = window.adsbygoogle || []).push({});  ","brief":"\n什么是分支?简单地说,分支就是两个相对独立的时间线,正常情况下,独立的时间线永远不会有交集,彼此不知道对方的存在,只有特定情况下,两条时间线才会相遇,因为相遇...","summary":"什么是分支?简单地说,分支就是两个相对独立的时间线,正常情况下,独立的时间线永远不会有交集,彼此不知道对方的存在,只有特定情况下,两条时间线才会相遇,因为相遇,...","abstract":"什么是分支?简单地说,分支就是两个相对独立的时间线,正常情况下,独立的时间线永远不会有交集,彼此不知道对方的存在,只有特定情况下,两条时间线才会相遇,因为相遇,...","description":"","picture":"","coverImageUrl":"","sourceType":99,"sourceDetail":{},"channelType":2,"channelDetail":{"source":"oschina","originalTime":"03/19 10:13"},"authorId":2952369,"columnId":75668,"writeTime":1554275489,"updateTime":1554275489,"viewCount":70,"likeCount":3,"commentCount":0,"weight":0,"status":2,"draftId":0,"tagIds":[],"tags":[{"tagId":10283,"tagName":"Git"}],"isCommentEnable":true,"column":{"id":75668,"name":"雪之梦技术驿站","desc":"雪之梦技术驿站又名snowdreams1006的技术小屋.主要分享个人的学习经验,一家之言,仅供参考.","icon":"https://ask.qcloudimg.com/column-icons/75668/2952369/rs2libapbs.png","background":"","status":2,"creatorId":2952369,"memberCount":1,"articleCount":67,"followCount":12,"createdTime":1553570025}}},{"id":2680,"type":40,"actionInfo":{"articleId":1409885,"columnId":75668,"articleOwnerUid":2952369},"createTime":1554275478,"detail":{"id":1409885,"articleId":1409885,"title":"git 入门教程之远程仓库\n                                                                            原","content":"entityMap|0|type|LINK|mutability|MUTABLE|data|url|https://github.com/|1|https://my.oschina.net/..github/usage.md|2|IMAGE|IMMUTABLE|imageUrl|https://ask.qcloudimg.com/http-save/yehe-2952369/804cfo7dnt.png|imageAlt|github-updated.png|blocks|key|2vkdt|text|unstyled|depth|inlineStyleRanges|entityRanges|cbt79|如果说本地仓库已经足够个人进行版本控制了,那么远程仓库则使多人合作开发成为可能.+如果你只是打算自己使用git,你的工作内容不需要发布给其他人看,那就用不到远程仓库的概念.|offset|length|style|CODE|1s3r|git+是分布式版本控制系统,分布式意味着同一个git+仓库+可以部署在不同的机器上,正如\"鸡生蛋蛋生鸡\"问题一样,不论如何,先要有一个原始仓库,然后才能分布到其他机器上去.|BOLD|201fb|充当原始仓库的机器要有一个特点那就是24h+开机且大家都能访问到,这个概念类似于\"中央服务器\".这样一来大家都可以从\"中央服务器\"下载最新代码,克隆到本地,本地发生更改后再推送给\"中央服务器\".如此一来,大家交流方便很多,轻松实现文件内容的共享.|e8v11|这种\"中央服务器\"比较有名的是国外的网站+github,当然国内也有不少类似服务.像这种\"中央服务器\"也可以自己搭建,现阶段搭建的话简直就是\"杀鸡焉用牛刀\"!|6nqm7|背景|header-two|b7a9m|关于如何注册配置相关请参考+github+教程|5cke9|为了和上述教程保持一致,项目名git-demo,先看一下当前工作区状态:|ae14k|#+查看文件列表\n$+ls\nLICENSE+++++README.md+++test.txt\n#+查看文件内容\n$+cat+test.txt\nadd+test.txt|code-block|syntax|javascript|flfps|现在测试一下本地更改能否推送到远程仓库,先在本地文件+test.txt+随便写点东西,然后添加(git+add),提交(git+commit),最后推送到远程仓库(git+push+origin+master).|8trbt|#+写入新的内容并提交到本地仓库\n$+echo+\"see+https://snowdreams1006.github.io/git/usage/remote-repository.html\"+>>+test.txt\n$+git+add+test.txt\n$+git+commit+-m+\"see+https://snowdreams1006.github.io/git/usage/remote-repository.html\"\n[master+b3d8193]+see+https://snowdreams1006.github.io/git/usage/remote-repository.html\n+1+file+changed,+1+insertion(%2B)\n\n#+推送到远程仓库\n$+git+push+origin+master\nCounting+objects:+3,+done.\nDelta+compression+using+up+to+4+threads.\nCompressing+objects:+100%25+(3/3),+done.\nWriting+objects:+100%25+(3/3),+359+bytes+%7C+359.00+KiB/s,+done.\nTotal+3+(delta+1),+reused+0+(delta+0)\nremote:+Resolving+deltas:+100%25+(1/1),+completed+with+1+local+object.\nTo+github.com:snowdreams1006/git-demo.git\n+++8e62564..b3d8193++master+->+master\n$+|62t6o|命令行没有报错证明我们已经成功推送到+github,现在登录+github+看一下有没有刚才我们提交的新内容.|afhf9|?|atomic|c9kbb|现在本地版本库和远程版本库已经能够正常建立关联了,此刻起将不再是独自一人在战斗!|13dr8|小结|ddsm2|创建已有本地仓库和远程仓库的关联|unordered-list-item|1ckhl|#+添加远程仓库关联\ngit+remote+add+origin+git@github.com:username/repos.git\n\n#+首次推送+master+分支的全部内容\ngit+push+-u+origin+master\n\n#+后续推送+master+分支的最新更改\ngit+push+origin+master|fstnq|从已有远程仓库克隆到本地仓库|53o29|#+克隆远程仓库到本地仓库\ngit+clone+git@github.com:username/repos.git\n\n#+推送+master+分支的最新更改\ngit+push+origin+master|ducfe|+++++(adsbygoogle+=+window.adsbygoogle+%7C%7C+[]).push({});++^0|0|1G|3|0|0|3|O|6|5|9|0|0|L|6|0|0|0|E|9|1|0|F|8|0|0|R|8|1C|7|1O|A|2A|M|0|0|J|6|V|6|0|0|1|2|0|0|0|0|0|0|0^^$0|$1|$2|3|4|5|6|$7|8]]|9|$2|3|4|5|6|$7|A]]|B|$2|C|4|D|6|$E|F|G|H]]]|I|@$J|K|L|-4|2|M|N|23|O|@]|P|@]|6|$]]|$J|Q|L|R|2|M|N|24|O|@$S|25|T|26|U|V]]|P|@]|6|$]]|$J|W|L|X|2|M|N|27|O|@$S|28|T|29|U|V]|$S|2A|T|2B|U|V]|$S|2C|T|2D|U|Y]]|P|@]|6|$]]|$J|Z|L|10|2|M|N|2E|O|@]|P|@]|6|$]]|$J|11|L|12|2|M|N|2F|O|@]|P|@$S|2G|T|2H|J|2I]]|6|$]]|$J|13|L|14|2|15|N|2J|O|@]|P|@]|6|$]]|$J|16|L|17|2|M|N|2K|O|@]|P|@$S|2L|T|2M|J|2N]]|6|$]]|$J|18|L|19|2|M|N|2O|O|@$S|2P|T|2Q|U|V]]|P|@]|6|$]]|$J|1A|L|1B|2|1C|N|2R|O|@]|P|@]|6|$1D|1E]]|$J|1F|L|1G|2|M|N|2S|O|@$S|2T|T|2U|U|V]|$S|2V|T|2W|U|V]|$S|2X|T|2Y|U|V]|$S|2Z|T|30|U|V]]|P|@]|6|$]]|$J|1H|L|1I|2|1C|N|31|O|@]|P|@]|6|$1D|1E]]|$J|1J|L|1K|2|M|N|32|O|@$S|33|T|34|U|V]|$S|35|T|36|U|V]]|P|@]|6|$]]|$J|1L|L|1M|2|1N|N|37|O|@]|P|@$S|38|T|39|J|3A]]|6|$]]|$J|1O|L|1P|2|M|N|3B|O|@]|P|@]|6|$]]|$J|1Q|L|1R|2|15|N|3C|O|@]|P|@]|6|$]]|$J|1S|L|1T|2|1U|N|3D|O|@]|P|@]|6|$]]|$J|1V|L|1W|2|1C|N|3E|O|@]|P|@]|6|$1D|1E]]|$J|1X|L|1Y|2|1U|N|3F|O|@]|P|@]|6|$]]|$J|1Z|L|20|2|1C|N|3G|O|@]|P|@]|6|$1D|1E]]|$J|21|L|22|2|M|N|3H|O|@]|P|@]|6|$]]]]","plain":"\n如果说本地仓库已经足够个人进行版本控制了,那么远程仓库则使多人合作开发成为可能. 如果你只是打算自己使用git,你的工作内容不需要发布给其他人看,那就用不到远程仓库的概念.\ngit 是分布式版本控制系统,分布式意味着同一个git 仓库 可以部署在不同的机器上,正如\"鸡生蛋蛋生鸡\"问题一样,不论如何,先要有一个原始仓库,然后才能分布到其他机器上去.\n充当原始仓库的机器要有一个特点那就是24h 开机且大家都能访问到,这个概念类似于\"中央服务器\".这样一来大家都可以从\"中央服务器\"下载最新代码,克隆到本地,本地发生更改后再推送给\"中央服务器\".如此一来,大家交流方便很多,轻松实现文件内容的共享.\n这种\"中央服务器\"比较有名的是国外的网站 github,当然国内也有不少类似服务.像这种\"中央服务器\"也可以自己搭建,现阶段搭建的话简直就是\"杀鸡焉用牛刀\"!\n背景\n关于如何注册配置相关请参考 github 教程\n为了和上述教程保持一致,项目名git-demo,先看一下当前工作区状态:\n# 查看文件列表\n$ ls\nLICENSE     README.md   test.txt\n# 查看文件内容\n$ cat test.txt\nadd test.txt\n现在测试一下本地更改能否推送到远程仓库,先在本地文件 test.txt 随便写点东西,然后添加(git add),提交(git commit),最后推送到远程仓库(git push origin master).\n# 写入新的内容并提交到本地仓库\n$ echo \"see https://snowdreams1006.github.io/git/usage/remote-repository.html\" >> test.txt\n$ git add test.txt\n$ git commit -m \"see https://snowdreams1006.github.io/git/usage/remote-repository.html\"\n[master b3d8193] see https://snowdreams1006.github.io/git/usage/remote-repository.html\n 1 file changed, 1 insertion(+)\n\n# 推送到远程仓库\n$ git push origin master\nCounting objects: 3, done.\nDelta compression using up to 4 threads.\nCompressing objects: 100% (3/3), done.\nWriting objects: 100% (3/3), 359 bytes | 359.00 KiB/s, done.\nTotal 3 (delta 1), reused 0 (delta 0)\nremote: Resolving deltas: 100% (1/1), completed with 1 local object.\nTo github.com:snowdreams1006/git-demo.git\n   8e62564..b3d8193  master -> master\n$ \n命令行没有报错证明我们已经成功推送到 github,现在登录 github 看一下有没有刚才我们提交的新内容.\n?\n现在本地版本库和远程版本库已经能够正常建立关联了,此刻起将不再是独自一人在战斗!\n小结\n创建已有本地仓库和远程仓库的关联\n# 添加远程仓库关联\ngit remote add origin git@github.com:username/repos.git\n\n# 首次推送 master 分支的全部内容\ngit push -u origin master\n\n# 后续推送 master 分支的最新更改\ngit push origin master\n从已有远程仓库克隆到本地仓库\n# 克隆远程仓库到本地仓库\ngit clone git@github.com:username/repos.git\n\n# 推送 master 分支的最新更改\ngit push origin master\n     (adsbygoogle = window.adsbygoogle || []).push({});  ","brief":"\n如果说本地仓库已经足够个人进行版本控制了,那么远程仓库则使多人合作开发成为可能. 如果你只是打算自己使用git,你的工作内容不需要发布给其他人看,那就用不到远...","summary":"如果说本地仓库已经足够个人进行版本控制了,那么远程仓库则使多人合作开发成为可能. 如果你只是打算自己使用git,你的工作内容不需要发布给其他人看,那就用不到远程...","abstract":"如果说本地仓库已经足够个人进行版本控制了,那么远程仓库则使多人合作开发成为可能. 如果你只是打算自己使用git,你的工作内容不需要发布给其他人看,那就用不到远程...","description":"","picture":"https://ask.qcloudimg.com/http-save/yehe-2952369/804cfo7dnt.png","coverImageUrl":"https://ask.qcloudimg.com/http-save/yehe-2952369/804cfo7dnt.png","sourceType":99,"sourceDetail":{},"channelType":2,"channelDetail":{"source":"oschina","originalTime":"03/18 12:21"},"authorId":2952369,"columnId":75668,"writeTime":1554275478,"updateTime":1554275478,"viewCount":110,"likeCount":3,"commentCount":0,"weight":0,"status":2,"draftId":0,"tagIds":[],"tags":[{"tagId":10667,"tagName":"开源"},{"tagId":10283,"tagName":"Git"},{"tagId":10284,"tagName":"GitHub"},{"tagId":10668,"tagName":"分布式"}],"isCommentEnable":true,"column":{"id":75668,"name":"雪之梦技术驿站","desc":"雪之梦技术驿站又名snowdreams1006的技术小屋.主要分享个人的学习经验,一家之言,仅供参考.","icon":"https://ask.qcloudimg.com/column-icons/75668/2952369/rs2libapbs.png","background":"","status":2,"creatorId":2952369,"memberCount":1,"articleCount":67,"followCount":12,"createdTime":1553570025}}},{"id":2679,"type":40,"actionInfo":{"articleId":1409884,"columnId":75668,"articleOwnerUid":2952369},"createTime":1554275462,"detail":{"id":1409884,"articleId":1409884,"title":"git 入门教程之删除文件\n                                                                            原","content":"entityMap|blocks|key|euupi|text|type|unstyled|depth|inlineStyleRanges|entityRanges|data|au4hs|删除文件|header-one|bvkd2|回忆一下文件的常见操作,新增文件,修改文件,删除文件等,新增和修改文件都单独讨论过,现在我们来研究一下如何删除文件.|2dvi8|你可能会说删除文件还不简单啊,直接+rm+-rf+<file>+即可,但是这仅仅是本地文件被删除了,对于+git+来说,文件并没有被删除.|offset|length|style|CODE|9b1b2|还记得我们开篇介绍git+时就说过,一切操作皆版本+,对于新增是一个版本,修改也是一个版本,就连删除都是一个版本.|d20lu|下面让我们看一下+git+中如何删除文件吧!|6s2sa|背景|header-two|ardh0|#+查看当前文件列表\n$+ls\nfile1.txt+++file2.txt+++file3.txt+++newFile.txt+test.txt\n#+新建待删除文件\n$+touch+delete.txt\n#+再次查看当前文件列表,确保新建文件成功\n$+ls\ndelete.txt++file2.txt+++newFile.txt\nfile1.txt+++file3.txt+++test.txt\n#+查看当前文件状态:+新文件+`delete.txt`+还没被跟踪\n$+git+status\nOn+branch+master\nUntracked+files:\n++(use+\"git+add+<file>...\"+to+include+in+what+will+be+committed)\n\n++++.DS_Store\n++++delete.txt\n\nnothing+added+to+commit+but+untracked+files+present+(use+\"git+add\"+to+track)\n#+添加新文件+`delete.txt`\n$+git+add+delete.txt\n#+查看文件状态:+已添加到暂存区,待提交到版本库\n$+git+status\nOn+branch+master\nChanges+to+be+committed:\n++(use+\"git+reset+HEAD+<file>...\"+to+unstage)\n\n++++new+file:+++delete.txt\n\nUntracked+files:\n++(use+\"git+add+<file>...\"+to+include+in+what+will+be+committed)\n\n++++.DS_Store\n\n#+提交新文件+`delete.txt`\n$+git+commit+-m+\"add+delete.txt\"\n[master+7df386a]+add+delete.txt\n+1+file+changed,+0+insertions(%2B),+0+deletions(-)\n+create+mode+100644+delete.txt\n#+再次查看文件状态:+已经没有新文件+`delete.txt`+的更改信息\n$+git+status\nOn+branch+master\nUntracked+files:\n++(use+\"git+add+<file>...\"+to+include+in+what+will+be+committed)\n\n++++.DS_Store\n\nnothing+added+to+commit+but+untracked+files+present+(use+\"git+add\"+to+track)\n$+|code-block|syntax|javascript|592ih|以上操作,我们简单创建+delete.txt+文件,添加(git+add)并提交(git+commit)+该文件,完成准备工作后,开始删除文件!|eqrpm|#+删除前文件列表\n$+ls\ndelete.txt++file2.txt+++newFile.txt\nfile1.txt+++file3.txt+++test.txt\n#+删除刚刚创建的文件+`delete.txt`\n$+rm+delete.txt\n#+删除后文件列表\n$+ls\nfile1.txt+++file2.txt+++file3.txt+++newFile.txt+test.txt\n#+当前文件状态:+`delete.txt`+文件已被删除,且未添加到暂存区\n$+git+status\nOn+branch+master\nChanges+not+staged+for+commit:\n++(use+\"git+add/rm+<file>...\"+to+update+what+will+be+committed)\n++(use+\"git+checkout+--+<file>...\"+to+discard+changes+in+working+directory)\n\n++++deleted:++++delete.txt\n\nUntracked+files:\n++(use+\"git+add+<file>...\"+to+include+in+what+will+be+committed)\n\n++++.DS_Store\n\nno+changes+added+to+commit+(use+\"git+add\"+and/or+\"git+commit+-a\")\n$+|5p34f|本地删除+delete.txt+文件后,再次查看文件状态+git+status+发现+git+给了我们两条建议,其中一条+git+checkout+--+<file>+我们很熟悉,就是丢弃工作区的更改,此时此景下如果丢弃删除操作,相当于撤销删除,难怪说删除也是一个版本呢!|8qrdu|现在我们重点来看第一条建议+git+add/rm+<file>+,rm+是+remove+单词的缩写,即删除文件.|3qnkt|#+删除文件\n$+git+rm+delete.txt\nrm+'delete.txt'\n#+查看文件状态:+`delete.txt`+文件待提交\n$+git+status\nOn+branch+master\nChanges+to+be+committed:\n++(use+\"git+reset+HEAD+<file>...\"+to+unstage)\n\n++++deleted:++++delete.txt\n\nUntracked+files:\n++(use+\"git+add+<file>...\"+to+include+in+what+will+be+committed)\n\n++++.DS_Store\n\n#+提交文件\n$+git+commit+-m+\"remove+delete.txt\"\n[master+6298070]+remove+delete.txt\n+1+file+changed,+0+insertions(%2B),+0+deletions(-)\n+delete+mode+100644+delete.txt\n#+再次查看文件状态\n$+git+status\nOn+branch+master\nUntracked+files:\n++(use+\"git+add+<file>...\"+to+include+in+what+will+be+committed)\n\n++++.DS_Store\n\nnothing+added+to+commit+but+untracked+files+present+(use+\"git+add\"+to+track)\n$+|8bdsu|删除文件和添加文件类似,都是一次commit+,本地文件的任何更改都要添加到暂存区,然后提交到版本库.|eiqlk|小结|buhj3|删除文件和新增文件类似逻辑,git+rm+删除文件后,依然需要+git+commit+提交版本.|3krcq|+++++(adsbygoogle+=+window.adsbygoogle+%7C%7C+[]).push({});++^0|0|0|0|I|D|1H|3|0|9|3|I|7|0|9|3|0|0|0|C|A|T|7|15|A|0|0|5|A|T|A|17|3|1P|M|0|E|H|X|2|12|6|0|0|G|6|0|0|E|6|W|A|0^^$0|$]|1|@$2|3|4|-4|5|6|7|1G|8|@]|9|@]|A|$]]|$2|B|4|C|5|D|7|1H|8|@]|9|@]|A|$]]|$2|E|4|F|5|6|7|1I|8|@]|9|@]|A|$]]|$2|G|4|H|5|6|7|1J|8|@$I|1K|J|1L|K|L]|$I|1M|J|1N|K|L]]|9|@]|A|$]]|$2|M|4|N|5|6|7|1O|8|@$I|1P|J|1Q|K|L]|$I|1R|J|1S|K|L]]|9|@]|A|$]]|$2|O|4|P|5|6|7|1T|8|@$I|1U|J|1V|K|L]]|9|@]|A|$]]|$2|Q|4|R|5|S|7|1W|8|@]|9|@]|A|$]]|$2|T|4|U|5|V|7|1X|8|@]|9|@]|A|$W|X]]|$2|Y|4|Z|5|6|7|1Y|8|@$I|1Z|J|20|K|L]|$I|21|J|22|K|L]|$I|23|J|24|K|L]]|9|@]|A|$]]|$2|10|4|11|5|V|7|25|8|@]|9|@]|A|$W|X]]|$2|12|4|13|5|6|7|26|8|@$I|27|J|28|K|L]|$I|29|J|2A|K|L]|$I|2B|J|2C|K|L]|$I|2D|J|2E|K|L]]|9|@]|A|$]]|$2|14|4|15|5|6|7|2F|8|@$I|2G|J|2H|K|L]|$I|2I|J|2J|K|L]|$I|2K|J|2L|K|L]]|9|@]|A|$]]|$2|16|4|17|5|V|7|2M|8|@]|9|@]|A|$W|X]]|$2|18|4|19|5|6|7|2N|8|@$I|2O|J|2P|K|L]]|9|@]|A|$]]|$2|1A|4|1B|5|S|7|2Q|8|@]|9|@]|A|$]]|$2|1C|4|1D|5|6|7|2R|8|@$I|2S|J|2T|K|L]|$I|2U|J|2V|K|L]]|9|@]|A|$]]|$2|1E|4|1F|5|6|7|2W|8|@]|9|@]|A|$]]]]","plain":"\n删除文件\n回忆一下文件的常见操作,新增文件,修改文件,删除文件等,新增和修改文件都单独讨论过,现在我们来研究一下如何删除文件.\n你可能会说删除文件还不简单啊,直接 rm -rf <file> 即可,但是这仅仅是本地文件被删除了,对于 git 来说,文件并没有被删除.\n还记得我们开篇介绍git 时就说过,一切操作皆版本 ,对于新增是一个版本,修改也是一个版本,就连删除都是一个版本.\n下面让我们看一下 git 中如何删除文件吧!\n背景\n# 查看当前文件列表\n$ ls\nfile1.txt   file2.txt   file3.txt   newFile.txt test.txt\n# 新建待删除文件\n$ touch delete.txt\n# 再次查看当前文件列表,确保新建文件成功\n$ ls\ndelete.txt  file2.txt   newFile.txt\nfile1.txt   file3.txt   test.txt\n# 查看当前文件状态: 新文件 `delete.txt` 还没被跟踪\n$ git status\nOn branch master\nUntracked files:\n  (use \"git add <file>...\" to include in what will be committed)\n\n    .DS_Store\n    delete.txt\n\nnothing added to commit but untracked files present (use \"git add\" to track)\n# 添加新文件 `delete.txt`\n$ git add delete.txt\n# 查看文件状态: 已添加到暂存区,待提交到版本库\n$ git status\nOn branch master\nChanges to be committed:\n  (use \"git reset HEAD <file>...\" to unstage)\n\n    new file:   delete.txt\n\nUntracked files:\n  (use \"git add <file>...\" to include in what will be committed)\n\n    .DS_Store\n\n# 提交新文件 `delete.txt`\n$ git commit -m \"add delete.txt\"\n[master 7df386a] add delete.txt\n 1 file changed, 0 insertions(+), 0 deletions(-)\n create mode 100644 delete.txt\n# 再次查看文件状态: 已经没有新文件 `delete.txt` 的更改信息\n$ git status\nOn branch master\nUntracked files:\n  (use \"git add <file>...\" to include in what will be committed)\n\n    .DS_Store\n\nnothing added to commit but untracked files present (use \"git add\" to track)\n$ \n以上操作,我们简单创建 delete.txt 文件,添加(git add)并提交(git commit) 该文件,完成准备工作后,开始删除文件!\n# 删除前文件列表\n$ ls\ndelete.txt  file2.txt   newFile.txt\nfile1.txt   file3.txt   test.txt\n# 删除刚刚创建的文件 `delete.txt`\n$ rm delete.txt\n# 删除后文件列表\n$ ls\nfile1.txt   file2.txt   file3.txt   newFile.txt test.txt\n# 当前文件状态: `delete.txt` 文件已被删除,且未添加到暂存区\n$ git status\nOn branch master\nChanges not staged for commit:\n  (use \"git add/rm <file>...\" to update what will be committed)\n  (use \"git checkout -- <file>...\" to discard changes in working directory)\n\n    deleted:    delete.txt\n\nUntracked files:\n  (use \"git add <file>...\" to include in what will be committed)\n\n    .DS_Store\n\nno changes added to commit (use \"git add\" and/or \"git commit -a\")\n$ \n本地删除 delete.txt 文件后,再次查看文件状态 git status 发现 git 给了我们两条建议,其中一条 git checkout -- <file> 我们很熟悉,就是丢弃工作区的更改,此时此景下如果丢弃删除操作,相当于撤销删除,难怪说删除也是一个版本呢!\n现在我们重点来看第一条建议 git add/rm <file> ,rm 是 remove 单词的缩写,即删除文件.\n# 删除文件\n$ git rm delete.txt\nrm 'delete.txt'\n# 查看文件状态: `delete.txt` 文件待提交\n$ git status\nOn branch master\nChanges to be committed:\n  (use \"git reset HEAD <file>...\" to unstage)\n\n    deleted:    delete.txt\n\nUntracked files:\n  (use \"git add <file>...\" to include in what will be committed)\n\n    .DS_Store\n\n# 提交文件\n$ git commit -m \"remove delete.txt\"\n[master 6298070] remove delete.txt\n 1 file changed, 0 insertions(+), 0 deletions(-)\n delete mode 100644 delete.txt\n# 再次查看文件状态\n$ git status\nOn branch master\nUntracked files:\n  (use \"git add <file>...\" to include in what will be committed)\n\n    .DS_Store\n\nnothing added to commit but untracked files present (use \"git add\" to track)\n$ \n删除文件和添加文件类似,都是一次commit ,本地文件的任何更改都要添加到暂存区,然后提交到版本库.\n小结\n删除文件和新增文件类似逻辑,git rm 删除文件后,依然需要 git commit 提交版本.\n     (adsbygoogle = window.adsbygoogle || []).push({});  ","brief":"\n删除文件\n回忆一下文件的常见操作,新增文件,修改文件,删除文件等,新增和修改文件都单独讨论过,现在我们来研究一下如何删除文件.\n你可能会说删除文件还不简单啊,...","summary":"回忆一下文件的常见操作,新增文件,修改文件,删除文件等,新增和修改文件都单独讨论过,现在我们来研究一下如何删除文件.","abstract":"回忆一下文件的常见操作,新增文件,修改文件,删除文件等,新增和修改文件都单独讨论过,现在我们来研究一下如何删除文件.","description":"","picture":"","coverImageUrl":"","sourceType":99,"sourceDetail":{},"channelType":2,"channelDetail":{"source":"oschina","originalTime":"03/18 12:14"},"authorId":2952369,"columnId":75668,"writeTime":1554275462,"updateTime":1554275462,"viewCount":68,"likeCount":2,"commentCount":0,"weight":0,"status":2,"draftId":0,"tagIds":[],"tags":[{"tagId":10283,"tagName":"Git"}],"isCommentEnable":true,"column":{"id":75668,"name":"雪之梦技术驿站","desc":"雪之梦技术驿站又名snowdreams1006的技术小屋.主要分享个人的学习经验,一家之言,仅供参考.","icon":"https://ask.qcloudimg.com/column-icons/75668/2952369/rs2libapbs.png","background":"","status":2,"creatorId":2952369,"memberCount":1,"articleCount":67,"followCount":12,"createdTime":1553570025}}},{"id":2673,"type":50,"actionInfo":{"columnId":75668,"columnOwnerUid":2952369},"createTime":1553570025,"detail":{"id":75668,"name":"雪之梦技术驿站","desc":"雪之梦技术驿站又名snowdreams1006的技术小屋.主要分享个人的学习经验,一家之言,仅供参考.","icon":"https://ask.qcloudimg.com/column-icons/75668/2952369/rs2libapbs.png","background":"","status":2,"creatorId":2952369,"memberCount":1,"articleCount":67,"followCount":12,"createdTime":1553570025}}]}}